["^ ","~:resource-id",["~:shadow.build.classpath/resource","wejure/js/chatSystem.js"],"~:compiled-at",1678933586649,"~:js","var module$node_modules$gun$browser = shadow.js.require(\"module$node_modules$gun$browser\", {});\nvar module$node_modules$gun$sea = shadow.js.require(\"module$node_modules$gun$sea\", {});\nvar gun$$module$wejure$js$chatSystem = module$node_modules$gun$browser({peers:[\"http:localhost:8001/gun\"]});\nvar user$$module$wejure$js$chatSystem = gun$$module$wejure$js$chatSystem.user().recall({sessionStorage:true});\nasync function init$$module$wejure$js$chatSystem(username) {\n  let recipientList = window.wejure.components.chatPage.recipient_list;\n  gun$$module$wejure$js$chatSystem.get(\"users\").map().once(user => {\n    if (user != username) {\n      wejure.components.chatPage.atom_conj(recipientList, user);\n    }\n  });\n}\nasync function storeMessage$$module$wejure$js$chatSystem(recipient, messageInput) {\n  if (recipient == \"Select recipient\" || recipient == \"\") {\n    alert(\"Select a peer first!\");\n  } else {\n    let senderPair = JSON.parse(sessionStorage.getItem(\"pair\"));\n    let receiverPub = \"\";\n    let receiverEPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + recipient).once((data, key) => {\n      receiverPub = Object.keys(data)[1].slice(1);\n    });\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + receiverPub).get(\"epub\").once((data, key) => {\n      receiverEPub = data;\n    });\n    let timeStamp = (new Date()).toUTCString();\n    let sender = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + senderPair.pub).get(\"alias\").once((data, key) => {\n      sender = data;\n    });\n    let pass = await SEA.secret(receiverEPub, senderPair);\n    let message = '\\x3cspan style\\x3d\"color: red\"\\x3e' + sender + \": \\x3c/span\\x3e\" + messageInput;\n    let encryptedMessage = await SEA.encrypt(message, pass);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(senderPair.pub).get(receiverPub).map().once(async(data, key) => {\n      let dec = await SEA.decrypt(data, pass);\n    });\n    wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \"\");\n  }\n}\nasync function displayMessage$$module$wejure$js$chatSystem(peer, prevPeer) {\n  await wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message_list, \"\");\n  let selfPair = JSON.parse(sessionStorage.getItem(\"pair\"));\n  if (prevPeer != \"Select recipient\" && prevPeer != \"\") {\n    let prevPeerPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + prevPeer).once((data, key) => {\n      prevPeerPub = Object.keys(data)[1].slice(1);\n    });\n    console.log(\"prevPeer: \" + prevPeer + \"prevPeerPub: \" + prevPeerPub);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(selfPair.pub).get(prevPeerPub).map().off();\n  }\n  if (peer != \"Select recipient\") {\n    let peerPub = \"\";\n    let peerEPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + peer).once((data, key) => {\n      peerPub = Object.keys(data)[1].slice(1);\n    });\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + peerPub).get(\"epub\").once((data, key) => {\n      peerEPub = data;\n    });\n    let passphrase = await SEA.secret(peerEPub, selfPair);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(selfPair.pub).get(peerPub).map().once(async(data$jscomp$0, key$jscomp$0) => {\n      let decryptedMessage = await SEA.decrypt(data$jscomp$0, passphrase);\n      let sender = \"\";\n      await gun$$module$wejure$js$chatSystem.get(\"~\" + selfPair.pub).get(\"alias\").once((data, key) => {\n        sender = data;\n      });\n      wejure.components.chatPage.atom_str(window.wejure.components.chatPage.message_list, \"\\x3cp\\x3e\" + key$jscomp$0 + \" \" + decryptedMessage + \"\\x3c/p\\x3e\");\n    });\n  }\n}\n/** @const */ \nvar module$wejure$js$chatSystem = {};\n/** @const */ \nmodule$wejure$js$chatSystem.displayMessage = displayMessage$$module$wejure$js$chatSystem;\n/** @const */ \nmodule$wejure$js$chatSystem.init = init$$module$wejure$js$chatSystem;\n/** @const */ \nmodule$wejure$js$chatSystem.storeMessage = storeMessage$$module$wejure$js$chatSystem;\n\n$CLJS.module$wejure$js$chatSystem=module$wejure$js$chatSystem;","~:js-symbol-names",["~#set",["module$wejure$js$chatSystem","displayMessage$$module$wejure$js$chatSystem","gun$$module$wejure$js$chatSystem","storeMessage$$module$wejure$js$chatSystem","user$$module$wejure$js$chatSystem","init$$module$wejure$js$chatSystem"]],"~:properties",["^5",["peers","storeMessage","displayMessage","sessionStorage","init"]],"~:source","import GUN from 'goog:module$node_modules$gun$browser';\r\nimport 'goog:module$node_modules$gun$sea';\r\n\r\nvar gun = GUN({ peers: ['http:localhost:8001/gun'] });                          // host configured in relay.js\r\nvar user = gun.user().recall({sessionStorage: true});\r\n\r\nexport async function init(username) {                                          // initialize the chat room: add all the users into the select box\r\n    let recipientList = window.wejure.components.chatPage.recipient_list;\r\n    gun.get('users').map().once((user) => {\r\n        if (user != username) {\r\n            wejure.components.chatPage.atom_conj(recipientList, user); \r\n        }\r\n    });\r\n}\r\n\r\nexport async function storeMessage(recipient, messageInput) {                   // store the message in gunDB\r\n    if (recipient == \"Select recipient\" || recipient == \"\") {\r\n        alert(\"Select a peer first!\");\r\n    }\r\n    else {\r\n        let senderPair = JSON.parse(sessionStorage.getItem('pair'));            // get the key pair of the sender\r\n        let receiverPub = \"\";\r\n        let receiverEPub = \"\";\r\n        await gun.get('~@'+recipient).once((data, key) => {                     // get the public key of the receiver\r\n            receiverPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        await gun.get('~'+receiverPub).get('epub').once((data, key) => {        // get the encryption public key of the receiver\r\n            receiverEPub = data;     \r\n        });\r\n        let timeStamp = new Date().toUTCString();                               // use the time of sending the message as the key of storing the message\r\n        let sender = \"\";\r\n        await gun.get('~'+senderPair.pub).get('alias').once((data, key) => {    // get the sender name\r\n            sender = data;\r\n        });\r\n        let pass = await SEA.secret(receiverEPub, senderPair);                  // get the encryption key\r\n        let message = '<span style=\"color: red\">' + sender + ': </span>' + messageInput; \r\n        let encryptedMessage = await SEA.encrypt(message, pass);                                            // encrypt the message\r\n        await gun.get(\"chat\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in sender's side\r\n        await gun.get(\"chat\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in receiver's side\r\n        await gun.get(\"chat\").get(senderPair.pub).get(receiverPub).map().once(async (data, key) => {\r\n            let dec = await SEA.decrypt(data, pass);\r\n            //console.log(key, data, 'decrypted: ', dec);\r\n        });\r\n        wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \"\");               // clear the message input box\r\n    }\r\n}\r\n\r\nexport async function displayMessage(peer, prevPeer) {                                                      // display the messages when a peer is selected\r\n    await wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message_list, \"\");        // clear the previously shown messages\r\n    let selfPair = JSON.parse(sessionStorage.getItem('pair'));                                              // get the key pair of the user\r\n    if (prevPeer != \"Select recipient\" && prevPeer != \"\") {                                                 \r\n        let prevPeerPub = \"\";\r\n        await gun.get('~@'+prevPeer).once((data, key) => {\r\n            prevPeerPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        console.log(\"prevPeer: \" + prevPeer + \"prevPeerPub: \" + prevPeerPub);\r\n        await gun.get('chat').get(selfPair.pub).get(prevPeerPub).map().off();\r\n    }\r\n    if (peer != \"Select recipient\") {\r\n        let peerPub = \"\";\r\n        let peerEPub = \"\";\r\n        await gun.get('~@'+peer).once((data, key) => {                                                      // get the public key of the peer\r\n            peerPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        await gun.get('~'+peerPub).get('epub').once((data, key) => {                                        // get the encryption public key of the peer\r\n            peerEPub = data;     \r\n        });\r\n        let passphrase = await SEA.secret(peerEPub, selfPair);                                              // get the decryption key\r\n        await gun.get('chat').get(selfPair.pub).get(peerPub).map().once(async (data, key) => {              // scan through the stored messages\r\n            let decryptedMessage = await SEA.decrypt(data, passphrase);                                     // decrypt the message\r\n            let sender = \"\";\r\n            await gun.get('~'+selfPair.pub).get('alias').once((data, key) => {\r\n                sender = data;\r\n            });\r\n            wejure.components.chatPage.atom_str(window.wejure.components.chatPage.message_list, '<p>' + key + ' ' + decryptedMessage + '</p>')  // add the message for screen output\r\n        });   \r\n    }\r\n}\r\n\r\n","~:source-map-json","{\n\"version\":3,\n\"file\":\"module$wejure$js$chatSystem.js\",\n\"lineCount\":81,\n\"mappings\":\"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\",\n\"sources\":[\"wejure/js/chatSystem.js\"],\n\"sourcesContent\":[\"import GUN from 'goog:module$node_modules$gun$browser';\\r\\nimport 'goog:module$node_modules$gun$sea';\\r\\n\\r\\nvar gun = GUN({ peers: ['http:localhost:8001/gun'] });                          // host configured in relay.js\\r\\nvar user = gun.user().recall({sessionStorage: true});\\r\\n\\r\\nexport async function init(username) {                                          // initialize the chat room: add all the users into the select box\\r\\n    let recipientList = window.wejure.components.chatPage.recipient_list;\\r\\n    gun.get('users').map().once((user) => {\\r\\n        if (user != username) {\\r\\n            wejure.components.chatPage.atom_conj(recipientList, user); \\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\nexport async function storeMessage(recipient, messageInput) {                   // store the message in gunDB\\r\\n    if (recipient == \\\"Select recipient\\\" || recipient == \\\"\\\") {\\r\\n        alert(\\\"Select a peer first!\\\");\\r\\n    }\\r\\n    else {\\r\\n        let senderPair = JSON.parse(sessionStorage.getItem('pair'));            // get the key pair of the sender\\r\\n        let receiverPub = \\\"\\\";\\r\\n        let receiverEPub = \\\"\\\";\\r\\n        await gun.get('~@'+recipient).once((data, key) => {                     // get the public key of the receiver\\r\\n            receiverPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        await gun.get('~'+receiverPub).get('epub').once((data, key) => {        // get the encryption public key of the receiver\\r\\n            receiverEPub = data;     \\r\\n        });\\r\\n        let timeStamp = new Date().toUTCString();                               // use the time of sending the message as the key of storing the message\\r\\n        let sender = \\\"\\\";\\r\\n        await gun.get('~'+senderPair.pub).get('alias').once((data, key) => {    // get the sender name\\r\\n            sender = data;\\r\\n        });\\r\\n        let pass = await SEA.secret(receiverEPub, senderPair);                  // get the encryption key\\r\\n        let message = '<span style=\\\"color: red\\\">' + sender + ': </span>' + messageInput; \\r\\n        let encryptedMessage = await SEA.encrypt(message, pass);                                            // encrypt the message\\r\\n        await gun.get(\\\"chat\\\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in sender's side\\r\\n        await gun.get(\\\"chat\\\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in receiver's side\\r\\n        await gun.get(\\\"chat\\\").get(senderPair.pub).get(receiverPub).map().once(async (data, key) => {\\r\\n            let dec = await SEA.decrypt(data, pass);\\r\\n            //console.log(key, data, 'decrypted: ', dec);\\r\\n        });\\r\\n        wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \\\"\\\");               // clear the message input box\\r\\n    }\\r\\n}\\r\\n\\r\\nexport async function displayMessage(peer, prevPeer) {                                                      // display the messages when a peer is selected\\r\\n    await wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message_list, \\\"\\\");        // clear the previously shown messages\\r\\n    let selfPair = JSON.parse(sessionStorage.getItem('pair'));                                              // get the key pair of the user\\r\\n    if (prevPeer != \\\"Select recipient\\\" && prevPeer != \\\"\\\") {                                                 \\r\\n        let prevPeerPub = \\\"\\\";\\r\\n        await gun.get('~@'+prevPeer).once((data, key) => {\\r\\n            prevPeerPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        console.log(\\\"prevPeer: \\\" + prevPeer + \\\"prevPeerPub: \\\" + prevPeerPub);\\r\\n        await gun.get('chat').get(selfPair.pub).get(prevPeerPub).map().off();\\r\\n    }\\r\\n    if (peer != \\\"Select recipient\\\") {\\r\\n        let peerPub = \\\"\\\";\\r\\n        let peerEPub = \\\"\\\";\\r\\n        await gun.get('~@'+peer).once((data, key) => {                                                      // get the public key of the peer\\r\\n            peerPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        await gun.get('~'+peerPub).get('epub').once((data, key) => {                                        // get the encryption public key of the peer\\r\\n            peerEPub = data;     \\r\\n        });\\r\\n        let passphrase = await SEA.secret(peerEPub, selfPair);                                              // get the decryption key\\r\\n        await gun.get('chat').get(selfPair.pub).get(peerPub).map().once(async (data, key) => {              // scan through the stored messages\\r\\n            let decryptedMessage = await SEA.decrypt(data, passphrase);                                     // decrypt the message\\r\\n            let sender = \\\"\\\";\\r\\n            await gun.get('~'+selfPair.pub).get('alias').once((data, key) => {\\r\\n                sender = data;\\r\\n            });\\r\\n            wejure.components.chatPage.atom_str(window.wejure.components.chatPage.message_list, '<p>' + key + ' ' + decryptedMessage + '</p>')  // add the message for screen output\\r\\n        });   \\r\\n    }\\r\\n}\\r\\n\\r\\n\"],\n\"names\":[\"gun\",\"GUN\",\"peers\",\"user\",\"recall\",\"sessionStorage\",\"init\",\"username\",\"recipientList\",\"window\",\"wejure\",\"components\",\"chatPage\",\"recipient_list\",\"get\",\"map\",\"once\",\"atom_conj\",\"storeMessage\",\"recipient\",\"messageInput\",\"alert\",\"senderPair\",\"JSON\",\"parse\",\"getItem\",\"receiverPub\",\"receiverEPub\",\"data\",\"key\",\"Object\",\"keys\",\"slice\",\"timeStamp\",\"toUTCString\",\"Date\",\"sender\",\"pub\",\"pass\",\"SEA\",\"secret\",\"message\",\"encryptedMessage\",\"encrypt\",\"put\",\"dec\",\"decrypt\",\"atom_reset\",\"displayMessage\",\"peer\",\"prevPeer\",\"message_list\",\"selfPair\",\"prevPeerPub\",\"console\",\"log\",\"off\",\"peerPub\",\"peerEPub\",\"passphrase\",\"decryptedMessage\",\"atom_str\",\"$jscomp$tmp$exports$module$name\"]\n}\n"]