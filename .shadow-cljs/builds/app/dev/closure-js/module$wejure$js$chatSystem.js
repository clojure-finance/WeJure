["^ ","~:resource-id",["~:shadow.build.classpath/resource","wejure/js/chatSystem.js"],"~:compiled-at",1679147267055,"~:js","var module$node_modules$gun$browser = shadow.js.require(\"module$node_modules$gun$browser\", {});\nvar module$node_modules$gun$sea = shadow.js.require(\"module$node_modules$gun$sea\", {});\nvar gun$$module$wejure$js$chatSystem = module$node_modules$gun$browser({peers:[\"http:localhost:8001/gun\"]});\nvar user$$module$wejure$js$chatSystem = gun$$module$wejure$js$chatSystem.user().recall({sessionStorage:true});\nasync function init$$module$wejure$js$chatSystem(username) {\n  let recipientList = window.wejure.components.chatPage.recipient_list;\n  gun$$module$wejure$js$chatSystem.get(\"users\").map().once(user => {\n    if (user != username) {\n      wejure.components.chatPage.atom_conj(recipientList, user);\n    }\n  });\n}\nasync function storeMessage$$module$wejure$js$chatSystem(recipient, messageInput) {\n  if (recipient == \"Select recipient\" || recipient == \"\") {\n    alert(\"Select a peer first!\");\n  } else {\n    let senderPair = JSON.parse(sessionStorage.getItem(\"pair\"));\n    let receiverPub = \"\";\n    let receiverEPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + recipient).once((data, key) => {\n      receiverPub = Object.keys(data)[1].slice(1);\n    });\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + receiverPub).get(\"epub\").once((data, key) => {\n      receiverEPub = data;\n    });\n    let timeStamp = (new Date()).toUTCString();\n    let sender = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + senderPair.pub).get(\"alias\").once((data, key) => {\n      sender = data;\n    });\n    let pass = await SEA.secret(receiverEPub, senderPair);\n    let message = {\"sender\":sender, \"content\":messageInput};\n    let encryptedMessage = await SEA.encrypt(message, pass);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);\n    wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \"\");\n  }\n}\nasync function displayMessage$$module$wejure$js$chatSystem(peer, prevPeer) {\n  let id = window.wejure.components.chatPage.counter;\n  let selfPair = JSON.parse(sessionStorage.getItem(\"pair\"));\n  if (prevPeer != \"Select recipient\" && prevPeer != \"\") {\n    let prevPeerPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + prevPeer).once((data, key) => {\n      prevPeerPub = Object.keys(data)[1].slice(1);\n    });\n    gun$$module$wejure$js$chatSystem.get(\"chat\").get(selfPair.pub).get(prevPeerPub).off();\n  }\n  if (peer != \"Select recipient\") {\n    let peerPub = \"\";\n    let peerEPub = \"\";\n    await gun$$module$wejure$js$chatSystem.get(\"~@\" + peer).once((data, key) => {\n      peerPub = Object.keys(data)[1].slice(1);\n    });\n    await gun$$module$wejure$js$chatSystem.get(\"~\" + peerPub).get(\"epub\").once((data, key) => {\n      peerEPub = data;\n    });\n    let passphrase = await SEA.secret(peerEPub, selfPair);\n    await gun$$module$wejure$js$chatSystem.get(\"chat\").get(selfPair.pub).get(peerPub).map().once(async(data$jscomp$0, key$jscomp$0) => {\n      let decryptedMessage = await SEA.decrypt(data$jscomp$0, passphrase);\n      let sender = \"\";\n      await gun$$module$wejure$js$chatSystem.get(\"~\" + selfPair.pub).get(\"alias\").once((data, key) => {\n        sender = data;\n      });\n      decryptedMessage[\"timestamp\"] = key$jscomp$0;\n      wejure.components.chatPage.atom_conj(window.wejure.components.chatPage.message_list, decryptedMessage);\n    });\n  }\n}\n/** @const */ \nvar module$wejure$js$chatSystem = {};\n/** @const */ \nmodule$wejure$js$chatSystem.displayMessage = displayMessage$$module$wejure$js$chatSystem;\n/** @const */ \nmodule$wejure$js$chatSystem.init = init$$module$wejure$js$chatSystem;\n/** @const */ \nmodule$wejure$js$chatSystem.storeMessage = storeMessage$$module$wejure$js$chatSystem;\n\n$CLJS.module$wejure$js$chatSystem=module$wejure$js$chatSystem;","~:js-symbol-names",["~#set",["module$wejure$js$chatSystem","displayMessage$$module$wejure$js$chatSystem","gun$$module$wejure$js$chatSystem","storeMessage$$module$wejure$js$chatSystem","user$$module$wejure$js$chatSystem","init$$module$wejure$js$chatSystem"]],"~:properties",["^5",["peers","storeMessage","displayMessage","sessionStorage","init"]],"~:source","import GUN from 'goog:module$node_modules$gun$browser';\r\nimport 'goog:module$node_modules$gun$sea';\r\n\r\nvar gun = GUN({ peers: ['http:localhost:8001/gun'] });                          // host configured in relay.js\r\nvar user = gun.user().recall({sessionStorage: true});\r\n\r\nexport async function init(username) {                                          // initialize the chat room: add all the users into the select box\r\n    let recipientList = window.wejure.components.chatPage.recipient_list;\r\n    gun.get('users').map().once((user) => {\r\n        if (user != username) {\r\n            wejure.components.chatPage.atom_conj(recipientList, user); \r\n        }\r\n    });\r\n}\r\n\r\nexport async function storeMessage(recipient, messageInput) {                   // store the message in gunDB\r\n    if (recipient == \"Select recipient\" || recipient == \"\") {\r\n        alert(\"Select a peer first!\");\r\n    }\r\n    else {\r\n        let senderPair = JSON.parse(sessionStorage.getItem('pair'));            // get the key pair of the sender\r\n        let receiverPub = \"\";\r\n        let receiverEPub = \"\";\r\n        await gun.get('~@'+recipient).once((data, key) => {                     // get the public key of the receiver\r\n            receiverPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        await gun.get('~'+receiverPub).get('epub').once((data, key) => {        // get the encryption public key of the receiver\r\n            receiverEPub = data;     \r\n        });\r\n        let timeStamp = new Date().toUTCString();                               // use the time of sending the message as the key of storing the message\r\n        let sender = \"\";\r\n        await gun.get('~'+senderPair.pub).get('alias').once((data, key) => {    // get the sender name\r\n            sender = data;\r\n        });\r\n        let pass = await SEA.secret(receiverEPub, senderPair);                  // get the encryption key\r\n        let message = {\"sender\": sender, \"content\": messageInput};\r\n        let encryptedMessage = await SEA.encrypt(message, pass);                                            // encrypt the message\r\n        await gun.get(\"chat\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in sender's side\r\n        await gun.get(\"chat\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in receiver's side\r\n        wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \"\");               // clear the message input box\r\n    }\r\n}\r\n\r\nexport async function displayMessage(peer, prevPeer) {                                                      // display the messages when a peer is selected\r\n    let id = window.wejure.components.chatPage.counter;\r\n    let selfPair = JSON.parse(sessionStorage.getItem('pair'));                                              // get the key pair of the user\r\n    if (prevPeer != \"Select recipient\" && prevPeer != \"\") {                                                 \r\n        let prevPeerPub = \"\";\r\n        await gun.get('~@'+prevPeer).once((data, key) => {\r\n            prevPeerPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        //console.log(\"prevPeer: \" + prevPeer + \" prevPeerPub: \" + prevPeerPub);\r\n        gun.get('chat').get(selfPair.pub).get(prevPeerPub).off();      \r\n    }\r\n    if (peer != \"Select recipient\") {\r\n        let peerPub = \"\";\r\n        let peerEPub = \"\";\r\n        await gun.get('~@'+peer).once((data, key) => {                                                      // get the public key of the peer\r\n            peerPub = Object.keys(data)[1].slice(1);      \r\n        });\r\n        await gun.get('~'+peerPub).get('epub').once((data, key) => {                                        // get the encryption public key of the peer\r\n            peerEPub = data;     \r\n        });\r\n        let passphrase = await SEA.secret(peerEPub, selfPair);                                              // get the decryption key\r\n        await gun.get('chat').get(selfPair.pub).get(peerPub).map().once(async (data, key) => {              // scan through the stored messages\r\n            let decryptedMessage = await SEA.decrypt(data, passphrase);                                     // decrypt the message\r\n            let sender = \"\";\r\n            await gun.get('~'+selfPair.pub).get('alias').once((data, key) => {\r\n                sender = data;\r\n            });\r\n            decryptedMessage[\"timestamp\"] = key;                                                                        // add timestamp to the message output\r\n            wejure.components.chatPage.atom_conj(window.wejure.components.chatPage.message_list, decryptedMessage);     // add the message for screen output\r\n        });    \r\n    }\r\n}\r\n\r\n","~:source-map-json","{\n\"version\":3,\n\"file\":\"module$wejure$js$chatSystem.js\",\n\"lineCount\":78,\n\"mappings\":\"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\",\n\"sources\":[\"wejure/js/chatSystem.js\"],\n\"sourcesContent\":[\"import GUN from 'goog:module$node_modules$gun$browser';\\r\\nimport 'goog:module$node_modules$gun$sea';\\r\\n\\r\\nvar gun = GUN({ peers: ['http:localhost:8001/gun'] });                          // host configured in relay.js\\r\\nvar user = gun.user().recall({sessionStorage: true});\\r\\n\\r\\nexport async function init(username) {                                          // initialize the chat room: add all the users into the select box\\r\\n    let recipientList = window.wejure.components.chatPage.recipient_list;\\r\\n    gun.get('users').map().once((user) => {\\r\\n        if (user != username) {\\r\\n            wejure.components.chatPage.atom_conj(recipientList, user); \\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\nexport async function storeMessage(recipient, messageInput) {                   // store the message in gunDB\\r\\n    if (recipient == \\\"Select recipient\\\" || recipient == \\\"\\\") {\\r\\n        alert(\\\"Select a peer first!\\\");\\r\\n    }\\r\\n    else {\\r\\n        let senderPair = JSON.parse(sessionStorage.getItem('pair'));            // get the key pair of the sender\\r\\n        let receiverPub = \\\"\\\";\\r\\n        let receiverEPub = \\\"\\\";\\r\\n        await gun.get('~@'+recipient).once((data, key) => {                     // get the public key of the receiver\\r\\n            receiverPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        await gun.get('~'+receiverPub).get('epub').once((data, key) => {        // get the encryption public key of the receiver\\r\\n            receiverEPub = data;     \\r\\n        });\\r\\n        let timeStamp = new Date().toUTCString();                               // use the time of sending the message as the key of storing the message\\r\\n        let sender = \\\"\\\";\\r\\n        await gun.get('~'+senderPair.pub).get('alias').once((data, key) => {    // get the sender name\\r\\n            sender = data;\\r\\n        });\\r\\n        let pass = await SEA.secret(receiverEPub, senderPair);                  // get the encryption key\\r\\n        let message = {\\\"sender\\\": sender, \\\"content\\\": messageInput};\\r\\n        let encryptedMessage = await SEA.encrypt(message, pass);                                            // encrypt the message\\r\\n        await gun.get(\\\"chat\\\").get(senderPair.pub).get(receiverPub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in sender's side\\r\\n        await gun.get(\\\"chat\\\").get(receiverPub).get(senderPair.pub).get(timeStamp).put(encryptedMessage);    // store the encrypted message in receiver's side\\r\\n        wejure.components.chatPage.atom_reset(window.wejure.components.chatPage.message, \\\"\\\");               // clear the message input box\\r\\n    }\\r\\n}\\r\\n\\r\\nexport async function displayMessage(peer, prevPeer) {                                                      // display the messages when a peer is selected\\r\\n    let id = window.wejure.components.chatPage.counter;\\r\\n    let selfPair = JSON.parse(sessionStorage.getItem('pair'));                                              // get the key pair of the user\\r\\n    if (prevPeer != \\\"Select recipient\\\" && prevPeer != \\\"\\\") {                                                 \\r\\n        let prevPeerPub = \\\"\\\";\\r\\n        await gun.get('~@'+prevPeer).once((data, key) => {\\r\\n            prevPeerPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        //console.log(\\\"prevPeer: \\\" + prevPeer + \\\" prevPeerPub: \\\" + prevPeerPub);\\r\\n        gun.get('chat').get(selfPair.pub).get(prevPeerPub).off();      \\r\\n    }\\r\\n    if (peer != \\\"Select recipient\\\") {\\r\\n        let peerPub = \\\"\\\";\\r\\n        let peerEPub = \\\"\\\";\\r\\n        await gun.get('~@'+peer).once((data, key) => {                                                      // get the public key of the peer\\r\\n            peerPub = Object.keys(data)[1].slice(1);      \\r\\n        });\\r\\n        await gun.get('~'+peerPub).get('epub').once((data, key) => {                                        // get the encryption public key of the peer\\r\\n            peerEPub = data;     \\r\\n        });\\r\\n        let passphrase = await SEA.secret(peerEPub, selfPair);                                              // get the decryption key\\r\\n        await gun.get('chat').get(selfPair.pub).get(peerPub).map().once(async (data, key) => {              // scan through the stored messages\\r\\n            let decryptedMessage = await SEA.decrypt(data, passphrase);                                     // decrypt the message\\r\\n            let sender = \\\"\\\";\\r\\n            await gun.get('~'+selfPair.pub).get('alias').once((data, key) => {\\r\\n                sender = data;\\r\\n            });\\r\\n            decryptedMessage[\\\"timestamp\\\"] = key;                                                                        // add timestamp to the message output\\r\\n            wejure.components.chatPage.atom_conj(window.wejure.components.chatPage.message_list, decryptedMessage);     // add the message for screen output\\r\\n        });    \\r\\n    }\\r\\n}\\r\\n\\r\\n\"],\n\"names\":[\"gun\",\"GUN\",\"peers\",\"user\",\"recall\",\"sessionStorage\",\"init\",\"username\",\"recipientList\",\"window\",\"wejure\",\"components\",\"chatPage\",\"recipient_list\",\"get\",\"map\",\"once\",\"atom_conj\",\"storeMessage\",\"recipient\",\"messageInput\",\"alert\",\"senderPair\",\"JSON\",\"parse\",\"getItem\",\"receiverPub\",\"receiverEPub\",\"data\",\"key\",\"Object\",\"keys\",\"slice\",\"timeStamp\",\"toUTCString\",\"Date\",\"sender\",\"pub\",\"pass\",\"SEA\",\"secret\",\"message\",\"encryptedMessage\",\"encrypt\",\"put\",\"atom_reset\",\"displayMessage\",\"peer\",\"prevPeer\",\"id\",\"counter\",\"selfPair\",\"prevPeerPub\",\"off\",\"peerPub\",\"peerEPub\",\"passphrase\",\"decryptedMessage\",\"decrypt\",\"message_list\",\"$jscomp$tmp$exports$module$name\"]\n}\n"]