["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/gun/sea.js"],"~:js","shadow$provide.module$node_modules$gun$sea=function(global,require,module$jscomp$0,exports){var Buffer=require(\"module$node_modules$buffer$index\").Buffer;(function(){function USE(arg,req){return req?require(arg):arg.slice?USE[arg.split(\"/\").slice(-1).toString().replace(\".js\",\"\")]:function(mod,path){arg(mod={exports:{}});USE[path.split(\"/\").slice(-1).toString().replace(\".js\",\"\")]=mod.exports}}if(\"undefined\"!==typeof module$jscomp$0)var MODULE=module$jscomp$0;USE(function(module){\"undefined\"!==typeof self&&\n(module.window=self);\"undefined\"!==typeof window&&(module.window=window);var SEA=(module.window||module).SEA||{};if(SEA.window=module.window)SEA.window.SEA=SEA;try{\"undefined\"!==typeof MODULE&&(MODULE.exports=SEA)}catch(e){}module.exports=SEA})(USE,\"./root\");USE(function(module){module=USE(\"./root\");try{module.window&&0>location.protocol.indexOf(\"s\")&&0>location.host.indexOf(\"localhost\")&&!/^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname)&&0>location.protocol.indexOf(\"file:\")&&(console.warn(\"HTTPS needed for WebCrypto in SEA, redirecting...\"),\nlocation.protocol=\"https:\")}catch(e){}})(USE,\"./https\");USE(function(module){if(\"undefined\"==typeof btoa){if(\"undefined\"==typeof Buffer)try{global.Buffer=USE(\"buffer\",1).Buffer}catch(e){console.log(\"Please `npm install buffer` or add it to your package.json !\")}global.btoa=function(data){return Buffer.from(data,\"binary\").toString(\"base64\")};global.atob=function(data){return Buffer.from(data,\"base64\").toString(\"binary\")}}})(USE,\"./base64\");USE(function(module){function SeaArray(){}USE(\"./base64\");\nObject.assign(SeaArray,{from:Array.from});SeaArray.prototype=Object.create(Array.prototype);SeaArray.prototype.toString=function(enc,start,end){enc=enc||\"utf8\";start=start||0;const length=this.length;if(\"hex\"===enc){const buf=new Uint8Array(this);return[...Array((end&&end+1||length)-start).keys()].map(i=>buf[i+start].toString(16).padStart(2,\"0\")).join(\"\")}if(\"utf8\"===enc)return Array.from({length:(end||length)-start},(_,i)=>String.fromCharCode(this[i+start])).join(\"\");if(\"base64\"===enc)return btoa(this)};\nmodule.exports=SeaArray})(USE,\"./array\");USE(function(module){function SafeBuffer(...props){console.warn(\"new SafeBuffer() is depreciated, please use SafeBuffer.from()\");return SafeBuffer.from(...props)}USE(\"./base64\");var SeaArray=USE(\"./array\");SafeBuffer.prototype=Object.create(Array.prototype);Object.assign(SafeBuffer,{from(){if(!Object.keys(arguments).length||null==arguments[0])throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");const input=\narguments[0];if(\"string\"===typeof input){var enc=arguments[1]||\"utf8\";if(\"hex\"===enc){var buf=input.match(/([\\da-fA-F]{2})/g).map(byte=>parseInt(byte,16));if(!buf||!buf.length)throw new TypeError(\"Invalid first argument for type 'hex'.\");buf=SeaArray.from(buf)}else if(\"utf8\"===enc||\"binary\"===enc){buf=input.length;const words=new Uint16Array(buf);Array.from({length:buf},(_,i)=>words[i]=input.charCodeAt(i));buf=SeaArray.from(words)}else if(\"base64\"===enc){const dec=atob(input);buf=dec.length;const bytes=\nnew Uint8Array(buf);Array.from({length:buf},(_,i)=>bytes[i]=dec.charCodeAt(i));buf=SeaArray.from(bytes)}else\"binary\"===enc?buf=SeaArray.from(input):console.info(\"SafeBuffer.from unknown encoding: \"+enc);return buf}if(input.byteLength||input.length)return input instanceof ArrayBuffer&&(enc=new Uint8Array(input)),SeaArray.from(enc||input)},alloc(length,fill=0){return SeaArray.from(new Uint8Array(Array.from({length},()=>fill)))},allocUnsafe(length){return SeaArray.from(new Uint8Array(Array.from({length})))},\nconcat(arr){if(!Array.isArray(arr))throw new TypeError(\"First argument must be Array containing ArrayBuffer or Uint8Array instances.\");return SeaArray.from(arr.reduce((ret,item)=>ret.concat(Array.from(item)),[]))}});SafeBuffer.prototype.from=SafeBuffer.from;SafeBuffer.prototype.toString=SeaArray.prototype.toString;module.exports=SafeBuffer})(USE,\"./buffer\");USE(function(module){const SEA=USE(\"./root\"),api={Buffer:USE(\"./buffer\")};var o={};JSON.parseAsync=JSON.parseAsync||function(t,cb,r){try{cb(void 0,\nJSON.parse(t,r))}catch(e){cb(e)}};JSON.stringifyAsync=JSON.stringifyAsync||function(v,cb,r,s){try{cb(void 0,JSON.stringify(v,r,s))}catch(e){cb(e)}};api.parse=function(t,r){return new Promise(function(res,rej){JSON.parseAsync(t,function(err,raw){err?rej(err):res(raw)},r)})};api.stringify=function(v,r,s){return new Promise(function(res,rej){JSON.stringifyAsync(v,function(err,raw){err?rej(err):res(raw)},r,s)})};SEA.window&&(api.crypto=SEA.window.crypto||SEA.window.msCrypto,api.subtle=(api.crypto||o).subtle||\n(api.crypto||o).webkitSubtle,api.TextEncoder=SEA.window.TextEncoder,api.TextDecoder=SEA.window.TextDecoder,api.random=len=>api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len)))));if(!api.TextDecoder){const {TextEncoder,TextDecoder}=USE((\"undefined\"==typeof MODULE?\".\":\"\")+\"./lib/text-encoding\",1);api.TextDecoder=TextDecoder;api.TextEncoder=TextEncoder}if(!api.crypto)try{var crypto=USE(\"crypto\",1);Object.assign(api,{crypto,random:len=>api.Buffer.from(crypto.randomBytes(len))});\nconst {Crypto:WebCrypto}=USE(\"@peculiar/webcrypto\",1);api.ossl=api.subtle=(new WebCrypto({directory:\"ossl\"})).subtle}catch(e){console.log(\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\")}module.exports=api})(USE,\"./shim\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\"),s={pbkdf2:{hash:{name:\"SHA-256\"},iter:1E5,ks:64},ecdsa:{pair:{name:\"ECDSA\",namedCurve:\"P-256\"},sign:{name:\"ECDSA\",hash:{name:\"SHA-256\"}}},ecdh:{name:\"ECDH\",namedCurve:\"P-256\"},jwk:function(pub,\nd){pub=pub.split(\".\");pub={kty:\"EC\",crv:\"P-256\",x:pub[0],y:pub[1],ext:!0};pub.key_ops=d?[\"sign\"]:[\"verify\"];d&&(pub.d=d);return pub},keyToJwk:function(keyBytes){return{kty:\"oct\",k:keyBytes.toString(\"base64\").replace(/\\+/g,\"-\").replace(/\\//g,\"_\").replace(/=/g,\"\"),ext:!1,alg:\"A256GCM\"}},recall:{validity:43200,hook:function(props){return props}},check:function(t){return\"string\"==typeof t&&\"SEA{\"===t.slice(0,4)},parse:async function(t){try{var yes=\"string\"==typeof t;yes&&\"SEA{\"===t.slice(0,4)&&(t=t.slice(3));\nreturn yes?await shim.parse(t):t}catch(e){}return t}};SEA.opt=s;module.exports=s})(USE,\"./settings\");USE(function(module){var shim=USE(\"./shim\");module.exports=async function(d,o){d=\"string\"==typeof d?d:await shim.stringify(d);o=await shim.subtle.digest({name:o||\"SHA-256\"},(new shim.TextEncoder).encode(d));return shim.Buffer.from(o)}})(USE,\"./sha256\");USE(function(module){const __shim=USE(\"./shim\"),subtle=__shim.subtle,ossl=__shim.ossl?__shim.ossl:subtle;module.exports=b=>ossl.digest({name:\"SHA-1\"},\nnew ArrayBuffer(b))})(USE,\"./sha1\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\"),S=USE(\"./settings\"),sha=USE(\"./sha256\");SEA.work=SEA.work||(async(data,pair,cb,opt)=>{try{var salt=(pair||{}).epub||pair;opt=opt||{};salt instanceof Function&&(cb=salt,salt=void 0);data=\"string\"==typeof data?data:await shim.stringify(data);if(\"sha\"===(opt.name||\"\").toLowerCase().slice(0,3)){var rsha=shim.Buffer.from(await sha(data,opt.name),\"binary\").toString(opt.encode||\"base64\");if(cb)try{cb(rsha)}catch(e){console.log(e)}return rsha}salt=\nsalt||shim.random(9);var key=await (shim.ossl||shim.subtle).importKey(\"raw\",(new shim.TextEncoder).encode(data),{name:opt.name||\"PBKDF2\"},!1,[\"deriveBits\"]),work=await (shim.ossl||shim.subtle).deriveBits({name:opt.name||\"PBKDF2\",iterations:opt.iterations||S.pbkdf2.iter,salt:(new shim.TextEncoder).encode(opt.salt||salt),hash:opt.hash||S.pbkdf2.hash},key,opt.length||8*S.pbkdf2.ks);shim.random(data.length);var r=shim.Buffer.from(work,\"binary\").toString(opt.encode||\"base64\");if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);\nSEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.work})(USE,\"./work\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\");USE(\"./settings\");SEA.name=SEA.name||(async(cb,opt)=>{try{if(cb)try{cb()}catch(e){console.log(e)}}catch(e){console.log(e);SEA.err=e;if(SEA.throw)throw e;cb&&cb()}});SEA.pair=SEA.pair||(async(cb,opt)=>{try{var ecdhSubtle=shim.ossl||shim.subtle,sa=await shim.subtle.generateKey({name:\"ECDSA\",namedCurve:\"P-256\"},!0,[\"sign\",\"verify\"]).then(async keys=>{var key=\n{};key.priv=(await shim.subtle.exportKey(\"jwk\",keys.privateKey)).d;keys=await shim.subtle.exportKey(\"jwk\",keys.publicKey);key.pub=keys.x+\".\"+keys.y;return key});try{var dh=await ecdhSubtle.generateKey({name:\"ECDH\",namedCurve:\"P-256\"},!0,[\"deriveKey\"]).then(async keys=>{var key={};key.epriv=(await ecdhSubtle.exportKey(\"jwk\",keys.privateKey)).d;keys=await ecdhSubtle.exportKey(\"jwk\",keys.publicKey);key.epub=keys.x+\".\"+keys.y;return key})}catch(e){if(SEA.window)throw e;if(\"Error: ECDH is not a supported algorithm\"==\ne)console.log(\"Ignoring ECDH...\");else throw e;}dh=dh||{};var r={pub:sa.pub,priv:sa.priv,epub:dh.epub,epriv:dh.epriv};if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);SEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.pair})(USE,\"./pair\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\"),S=USE(\"./settings\"),sha=USE(\"./sha256\");SEA.sign=SEA.sign||(async(data,pair,cb,opt)=>{try{opt=opt||{};if(!(pair||opt).priv){if(!SEA.I)throw\"No signing key.\";pair=await SEA.I(null,\n{what:data,how:\"sign\",why:opt.why})}if(void 0===data)throw\"`undefined` not allowed.\";var json=await S.parse(data),check=opt.check=opt.check||json;if(SEA.verify&&(SEA.opt.check(check)||check&&check.s&&check.m)&&void 0!==await SEA.verify(check,pair)){var r=await S.parse(check);opt.raw||(r=\"SEA\"+await shim.stringify(r));if(cb)try{cb(r)}catch(e){console.log(e)}return r}var jwk=S.jwk(pair.pub,pair.priv),hash=await sha(json),sig=await (shim.ossl||shim.subtle).importKey(\"jwk\",jwk,{name:\"ECDSA\",namedCurve:\"P-256\"},\n!1,[\"sign\"]).then(key=>(shim.ossl||shim.subtle).sign({name:\"ECDSA\",hash:{name:\"SHA-256\"}},key,new Uint8Array(hash)));r={m:json,s:shim.Buffer.from(sig,\"binary\").toString(opt.encode||\"base64\")};opt.raw||(r=\"SEA\"+await shim.stringify(r));if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);SEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.sign})(USE,\"./sign\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\"),S=USE(\"./settings\"),sha=USE(\"./sha256\");SEA.verify=\nSEA.verify||(async(data,pair,cb,opt)=>{try{var json=await S.parse(data);if(!1===pair){var raw=await S.parse(json.m);if(cb)try{cb(raw)}catch(e){console.log(e)}return raw}opt=opt||{};var pub=pair.pub||pair,key=SEA.opt.slow_leak?await SEA.opt.slow_leak(pub):await (shim.ossl||shim.subtle).importKey(\"jwk\",S.jwk(pub),{name:\"ECDSA\",namedCurve:\"P-256\"},!1,[\"verify\"]),hash=await sha(json.m);try{var buf=shim.Buffer.from(json.s,opt.encode||\"base64\");var sig=new Uint8Array(buf);var check=await (shim.ossl||shim.subtle).verify({name:\"ECDSA\",\nhash:{name:\"SHA-256\"}},key,sig,new Uint8Array(hash));if(!check)throw\"Signature did not match.\";}catch(e){if(SEA.opt.fallback)return await SEA.opt.fall_verify(data,pair,cb,opt)}var r=check?await S.parse(json.m):void 0;if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);SEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.verify;var knownKeys={};SEA.opt.slow_leak=pair=>{if(knownKeys[pair])return knownKeys[pair];var jwk=S.jwk(pair);knownKeys[pair]=(shim.ossl||shim.subtle).importKey(\"jwk\",\njwk,{name:\"ECDSA\",namedCurve:\"P-256\"},!1,[\"verify\"]);return knownKeys[pair]};var O=SEA.opt;SEA.opt.fall_verify=async function(data,pair,cb,opt,f){if(f===SEA.opt.fallback)throw\"Signature did not match\";f=f||1;var tmp=data||\"\";data=SEA.opt.unpack(data)||data;var json=await S.parse(data);pair=await SEA.opt.slow_leak(pair.pub||pair);f=f<=SEA.opt.fallback?shim.Buffer.from(await shim.subtle.digest({name:\"SHA-256\"},(new shim.TextEncoder).encode(await S.parse(json.m)))):await sha(json.m);try{var buf=shim.Buffer.from(json.s,\nopt.encode||\"base64\");var sig=new Uint8Array(buf);var check=await (shim.ossl||shim.subtle).verify({name:\"ECDSA\",hash:{name:\"SHA-256\"}},pair,sig,new Uint8Array(f));if(!check)throw\"Signature did not match.\";}catch(e$jscomp$0){try{buf=shim.Buffer.from(json.s,\"utf8\"),sig=new Uint8Array(buf),check=await (shim.ossl||shim.subtle).verify({name:\"ECDSA\",hash:{name:\"SHA-256\"}},pair,sig,new Uint8Array(f))}catch(e){if(!check)throw\"Signature did not match.\";}}opt=check?await S.parse(json.m):void 0;O.fall_soul=\ntmp[\"#\"];O.fall_key=tmp[\".\"];O.fall_val=data;O.fall_state=tmp[\"\\x3e\"];if(cb)try{cb(opt)}catch(e){console.log(e)}return opt};SEA.opt.fallback=2})(USE,\"./verify\");USE(function(module){var shim=USE(\"./shim\"),S=USE(\"./settings\"),sha256hash=USE(\"./sha256\");module.exports=async(key,salt,opt)=>{key+=(salt||shim.random(8)).toString(\"utf8\");key=shim.Buffer.from(await sha256hash(key),\"binary\");key=S.keyToJwk(key);return await shim.subtle.importKey(\"jwk\",key,{name:\"AES-GCM\"},!1,[\"encrypt\",\"decrypt\"])}})(USE,\n\"./aeskey\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\");USE(\"./settings\");var aeskey=USE(\"./aeskey\");SEA.encrypt=SEA.encrypt||(async(data,pair,cb,opt)=>{try{opt=opt||{};var key=(pair||opt).epriv||pair;if(void 0===data)throw\"`undefined` not allowed.\";if(!key){if(!SEA.I)throw\"No encryption key.\";pair=await SEA.I(null,{what:data,how:\"encrypt\",why:opt.why});key=pair.epriv||pair}var msg=\"string\"==typeof data?data:await shim.stringify(data),JSCompiler_object_inline_s_112=shim.random(9),\nJSCompiler_object_inline_iv_113=shim.random(15),ct=await aeskey(key,JSCompiler_object_inline_s_112,opt).then(aes=>shim.subtle.encrypt({name:opt.name||\"AES-GCM\",iv:new Uint8Array(JSCompiler_object_inline_iv_113)},aes,(new shim.TextEncoder).encode(msg))),r={ct:shim.Buffer.from(ct,\"binary\").toString(opt.encode||\"base64\"),iv:JSCompiler_object_inline_iv_113.toString(opt.encode||\"base64\"),s:JSCompiler_object_inline_s_112.toString(opt.encode||\"base64\")};opt.raw||(r=\"SEA\"+await shim.stringify(r));if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);\nSEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.encrypt})(USE,\"./encrypt\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\"),S=USE(\"./settings\"),aeskey=USE(\"./aeskey\");SEA.decrypt=SEA.decrypt||(async(data,pair,cb,opt)=>{try{opt=opt||{};var key=(pair||opt).epriv||pair;if(!key){if(!SEA.I)throw\"No decryption key.\";pair=await SEA.I(null,{what:data,how:\"decrypt\",why:opt.why});key=pair.epriv||pair}var json=await S.parse(data);try{var buf=shim.Buffer.from(json.s,opt.encode||\"base64\");\nvar bufiv=shim.Buffer.from(json.iv,opt.encode||\"base64\");var bufct=shim.Buffer.from(json.ct,opt.encode||\"base64\");var ct=await aeskey(key,buf,opt).then(aes=>shim.subtle.decrypt({name:opt.name||\"AES-GCM\",iv:new Uint8Array(bufiv),tagLength:128},aes,new Uint8Array(bufct)))}catch(e){if(\"utf8\"===opt.encode)throw\"Could not decrypt\";if(SEA.opt.fallback)return opt.encode=\"utf8\",await SEA.decrypt(data,pair,cb,opt)}var r=await S.parse((new shim.TextDecoder(\"utf8\")).decode(ct));if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);\nSEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.decrypt})(USE,\"./decrypt\");USE(function(module){var SEA=USE(\"./root\"),shim=USE(\"./shim\");USE(\"./settings\");SEA.secret=SEA.secret||(async(key,pair,cb,opt)=>{try{opt=opt||{};if(!pair||!pair.epriv||!pair.epub){if(!SEA.I)throw\"No secret mix.\";pair=await SEA.I(null,{what:key,how:\"secret\",why:opt.why})}var epub=pair.epub,epriv=pair.epriv,ecdhSubtle=shim.ossl||shim.subtle,pubKeyData=keysToEcdhJwk(key.epub||key),props=Object.assign({public:await ecdhSubtle.importKey(...pubKeyData,\n!0,[])},{name:\"ECDH\",namedCurve:\"P-256\"}),privKeyData=keysToEcdhJwk(epub,epriv),r=await ecdhSubtle.importKey(...privKeyData,!1,[\"deriveBits\"]).then(async privKey=>{privKey=await ecdhSubtle.deriveBits(props,privKey,256);privKey=new Uint8Array(privKey);privKey=await ecdhSubtle.importKey(\"raw\",privKey,{name:\"AES-GCM\",length:256},!0,[\"encrypt\",\"decrypt\"]);return ecdhSubtle.exportKey(\"jwk\",privKey).then(({k})=>k)});if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){console.log(e);SEA.err=e;if(SEA.throw)throw e;\ncb&&cb()}});var keysToEcdhJwk=(pub,d)=>{var [x,y]=pub.split(\".\");return[\"jwk\",Object.assign(d?{d}:{},{x,y,kty:\"EC\",crv:\"P-256\",ext:!0}),{name:\"ECDH\",namedCurve:\"P-256\"}]};module.exports=SEA.secret})(USE,\"./secret\");USE(function(module){var SEA=USE(\"./root\");SEA.certify=SEA.certify||(async(certificants,policy={},authority,cb,opt={})=>{try{console.log(\"SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.\");certificants=\n(()=>{var data=[];if(certificants){if((\"string\"===typeof certificants||Array.isArray(certificants))&&-1<certificants.indexOf(\"*\"))return\"*\";if(\"string\"===typeof certificants)return certificants;if(Array.isArray(certificants)){if(1===certificants.length&&certificants[0])return\"object\"===typeof certificants[0]&&certificants[0].pub?certificants[0].pub:\"string\"===typeof certificants[0]?certificants[0]:null;certificants.map(certificant=>{\"string\"===typeof certificant?data.push(certificant):\"object\"===\ntypeof certificant&&certificant.pub&&data.push(certificant.pub)})}return\"object\"===typeof certificants&&certificants.pub?certificants.pub:0<data.length?data:null}})();if(!certificants)return console.log(\"No certificant found.\");const expiry=!opt.expiry||\"number\"!==typeof opt.expiry&&\"string\"!==typeof opt.expiry?null:parseFloat(opt.expiry),readPolicy=(policy||{}).read?policy.read:null,writePolicy=(policy||{}).write?policy.write:\"string\"===typeof policy||Array.isArray(policy)||policy[\"+\"]||policy[\"#\"]||\npolicy[\".\"]||policy[\"\\x3d\"]||policy[\"*\"]||policy[\"\\x3e\"]||policy[\"\\x3c\"]?policy:null,block=(opt||{}).block||(opt||{}).blacklist||(opt||{}).ban||{},readBlock=block.read&&(\"string\"===typeof block.read||(block.read||{})[\"#\"])?block.read:null,writeBlock=\"string\"===typeof block?block:block.write&&(\"string\"===typeof block.write||block.write[\"#\"])?block.write:null;if(!readPolicy&&!writePolicy)return console.log(\"No policy found.\");const data$jscomp$0=JSON.stringify({c:certificants,...(expiry?{e:expiry}:\n{}),...(readPolicy?{r:readPolicy}:{}),...(writePolicy?{w:writePolicy}:{}),...(readBlock?{rb:readBlock}:{}),...(writeBlock?{wb:writeBlock}:{})});var r=await SEA.sign(data$jscomp$0,authority,null,{raw:1});opt.raw||(r=\"SEA\"+JSON.stringify(r));if(cb)try{cb(r)}catch(e){console.log(e)}return r}catch(e){SEA.err=e;if(SEA.throw)throw e;cb&&cb()}});module.exports=SEA.certify})(USE,\"./certify\");USE(function(module){var shim=USE(\"./shim\"),SEA=USE(\"./root\");SEA.work=USE(\"./work\");SEA.sign=USE(\"./sign\");SEA.verify=\nUSE(\"./verify\");SEA.encrypt=USE(\"./encrypt\");SEA.decrypt=USE(\"./decrypt\");SEA.certify=USE(\"./certify\");SEA.random=SEA.random||shim.random;SEA.Buffer=SEA.Buffer||USE(\"./buffer\");SEA.keyid=SEA.keyid||(async pub=>{try{const pb=shim.Buffer.concat(pub.replace(/-/g,\"+\").replace(/_/g,\"/\").split(\".\").map(t=>shim.Buffer.from(t,\"base64\"))),id=shim.Buffer.concat([shim.Buffer.from([153,pb.length/256,pb.length%256]),pb]),sha1=await sha1hash(id),hash=shim.Buffer.from(sha1,\"binary\");return hash.toString(\"hex\",hash.length-\n8)}catch(e){throw console.log(e),e;}});((SEA.window||{}).GUN||{}).SEA=SEA;module.exports=SEA})(USE,\"./sea\");USE(function(module){function User(root){this._={$:this}}function lex(){return Gun.state().toString(36).replace(\".\",\"\")}var SEA=USE(\"./sea\");var Gun=SEA.window?SEA.window.GUN||{chain:{}}:USE((\"undefined\"==typeof MODULE?\".\":\"\")+\"./gun\",1);SEA.GUN=Gun;User.prototype=function(){function F(){}F.prototype=Gun.chain;return new F}();User.prototype.constructor=User;Gun.chain.user=function(pub$jscomp$0){var root=\nthis.back(-1);if(pub$jscomp$0)return pub$jscomp$0=SEA.opt.pub((pub$jscomp$0._||\"\")[\"#\"])||pub$jscomp$0,root.get(\"~\"+pub$jscomp$0);if(pub$jscomp$0=root.back(\"user\"))return pub$jscomp$0;var at=root=root._,uuid=at.opt.uuid||lex;(at=(pub$jscomp$0=at.user=this.chain(new User))._).opt={};at.opt.uuid=function(cb){var id=uuid(),pub=root.user;if(!pub||!(pub=pub.is)||!(pub=pub.pub))return id;id=\"~\"+pub+\"/\"+id;cb&&cb.call&&cb(null,id);return id};return pub$jscomp$0};Gun.User=User;User.GUN=Gun;User.SEA=Gun.SEA=\nSEA;module.exports=User})(USE,\"./user\");USE(function(module){(\"undefined\"!=typeof GUN?GUN||{chain:{}}:USE((\"undefined\"===typeof MODULE?\".\":\"\")+\"./gun\",1)).chain.then=function(cb,opt){var gun=this,p=new Promise(function(res,rej){gun.once(res,opt)});return cb?p.then(cb):p}})(USE,\"./then\");USE(function(module){module=USE(\"./user\");var SEA=module.SEA,Gun=module.GUN,noop=function(){};module.prototype.create=function(...args){var pair$jscomp$0=\"object\"===typeof args[0]&&(args[0].pub||args[0].epub)?args[0]:\n\"object\"===typeof args[1]&&(args[1].pub||args[1].epub)?args[1]:null,alias=pair$jscomp$0&&(pair$jscomp$0.pub||pair$jscomp$0.epub)?pair$jscomp$0.pub:\"string\"===typeof args[0]?args[0]:null,pass=pair$jscomp$0&&(pair$jscomp$0.pub||pair$jscomp$0.epub)?pair$jscomp$0:alias&&\"string\"===typeof args[1]?args[1]:null,cb=args.filter(arg=>\"function\"===typeof arg)[0]||null,opt=args&&1<args.length&&\"object\"===typeof args[args.length-1]?args[args.length-1]:{},gun=this,cat=gun._,root=gun.back(-1);cb=cb||noop;opt=opt||\n{};if(!1!==opt.check){var err;alias||(err=\"No user.\");8>(pass||\"\").length&&(err=\"Password too short!\");if(err)return cb({err:Gun.log(err)}),gun}if(cat.ing)return(cb||noop)({err:Gun.log(\"User is already being created or authenticated!\"),wait:!0}),gun;cat.ing=!0;var act={a:function(pubs){(act.pubs=pubs)&&!opt.already?(pubs={err:Gun.log(\"User already created!\")},cat.ing=!1,(cb||noop)(pubs),gun.leave()):(act.salt=String.random(64),SEA.work(pass,act.salt,act.b))},b:function(proof){act.proof=proof;pair$jscomp$0?\nact.c(pair$jscomp$0):SEA.pair(act.c)},c:function(pair){var tmp;act.pair=pair||{};if(tmp=cat.root.user)tmp._.sea=pair,tmp.is={pub:pair.pub,epub:pair.epub,alias};act.data={pub:pair.pub};act.d()},d:function(){act.data.alias=alias;act.e()},e:function(){act.data.epub=act.pair.epub;SEA.encrypt({priv:act.pair.priv,epriv:act.pair.epriv},act.proof,act.f,{raw:1})},f:function(auth){act.data.auth=JSON.stringify({ek:auth,s:act.salt});act.g(act.data.auth)},g:function(auth){act.data.auth=act.data.auth||auth;root.get(auth=\n\"~\"+act.pair.pub).put(act.data).on(act.h);var link={};link[auth]={\"#\":auth};root.get(\"~@\"+alias).put(link).get(auth).on(act.i)},h:function(data,key,msg,eve){eve.off();act.h.ok=1;act.i()},i:function(data,key,msg,eve){eve&&(act.i.ok=1,eve.off());act.h.ok&&act.i.ok&&(cat.ing=!1,cb({ok:0,pub:act.pair.pub}),noop===cb&&(pair$jscomp$0?gun.auth(pair$jscomp$0):gun.auth(alias,pass)))}};root.get(\"~@\"+alias).once(act.a);return gun};module.prototype.leave=function(opt,cb){if(opt=this.back(-1)._.user)delete opt.is,\ndelete opt._.is,delete opt._.sea;if(SEA.window)try{opt={},opt=SEA.window.sessionStorage,delete opt.recall,delete opt.pair}catch(e){}return this}})(USE,\"./create\");USE(function(module){function obj_ify(o){if(\"string\"!=typeof o)return o;try{o=JSON.parse(o)}catch(e){o={}}return o}module=USE(\"./user\");var SEA=module.SEA,Gun=module.GUN,noop=function(){};module.prototype.auth=function(...args){var pair$jscomp$0=\"object\"===typeof args[0]&&(args[0].pub||args[0].epub)?args[0]:\"object\"===typeof args[1]&&(args[1].pub||\nargs[1].epub)?args[1]:null,alias=pair$jscomp$0||\"string\"!==typeof args[0]?null:args[0],pass=!alias&&(!pair$jscomp$0||pair$jscomp$0.priv&&pair$jscomp$0.epriv)||\"string\"!==typeof args[1]?null:args[1],cb=args.filter(arg=>\"function\"===typeof arg)[0]||null,opt=args&&1<args.length&&\"object\"===typeof args[args.length-1]?args[args.length-1]:{},gun=this,cat=gun._,root=gun.back(-1);if(cat.ing)return(cb||noop)({err:Gun.log(\"User is already being created or authenticated!\"),wait:!0}),gun;cat.ing=!0;var act={},\ntries=9;act.a=function(data){if(!data)return act.b();if(!data.pub){var tmp=[];Object.keys(data).forEach(function(k){\"_\"!=k&&tmp.push(data[k])});return act.b(tmp)}if(act.name)return act.f(data);act.c((act.data=data).auth)};act.b=function(list){list=(act.list=(act.list||[]).concat(list||[])).shift();if(void 0===list){if(act.name)return act.err(\"Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.\");if(alias&&\ntries--){root.get(\"~@\"+alias).once(act.a);return}return act.err(\"Wrong user or password.\")}root.get(list).once(act.a)};act.c=function(auth){if(void 0===auth)return act.b();if(\"string\"==typeof auth)return act.c(obj_ify(auth));SEA.work(pass,(act.auth=auth).s,act.d,act.enc)};act.d=function(proof){SEA.decrypt(act.auth.ek,proof,act.e,act.enc)};act.e=function(half){if(void 0===half){if(!act.enc)return act.enc={encode:\"utf8\"},act.c(act.auth);act.enc=null;return act.b()}act.half=half;act.f(act.data)};act.f=\nfunction(pair){var half=act.half||{},data=act.data||{};act.g(act.lol={pub:pair.pub||data.pub,epub:pair.epub||data.epub,priv:pair.priv||half.priv,epriv:pair.epriv||half.epriv})};act.g=function(pair){if(!pair||!pair.pub||!pair.epub)return act.b();act.pair=pair;var user=root._.user,at=user._,upt=at.opt;at=user._=root.get(\"~\"+pair.pub)._;at.opt=upt;user.is={pub:pair.pub,epub:pair.epub,alias:alias||pair.pub};at.sea=act.pair;cat.ing=!1;try{pass&&void 0==(obj_ify(cat.root.graph[\"~\"+pair.pub].auth)||\"\")[\":\"]&&\n(opt.shuffle=opt.change=pass)}catch(e){}opt.change?act.z():(cb||noop)(at);if(SEA.window&&(gun.back(\"user\")._.opt||opt).remember)try{user={},user=SEA.window.sessionStorage,user.recall=!0,user.pair=JSON.stringify(pair)}catch(e){}try{if(root._.tag.auth)root._.on(\"auth\",at);else setTimeout(function(){root._.on(\"auth\",at)},1)}catch(e){Gun.log(\"Your 'auth' callback crashed with:\",e)}};act.h=function(data){if(!data)return act.b();alias=data.alias;alias||(alias=data.alias=\"~\"+pair$jscomp$0.pub);if(!data.auth)return act.g(pair$jscomp$0);\npair$jscomp$0=null;act.c((act.data=data).auth)};act.z=function(){act.salt=String.random(64);SEA.work(opt.change,act.salt,act.y)};act.y=function(proof){SEA.encrypt({priv:act.pair.priv,epriv:act.pair.epriv},proof,act.x,{raw:1})};act.x=function(auth){act.w(JSON.stringify({ek:auth,s:act.salt}))};act.w=function(auth){if(opt.shuffle){console.log(\"migrate core account from UTF8 \\x26 shuffle\");var tmp={};Object.keys(act.data).forEach(function(k){tmp[k]=act.data[k]});delete tmp._;tmp.auth=auth;root.get(\"~\"+\nact.pair.pub).put(tmp)}root.get(\"~\"+act.pair.pub).get(\"auth\").put(auth,cb||noop)};act.err=function(e){e={err:Gun.log(e||\"User cannot be found!\")};cat.ing=!1;(cb||noop)(e)};act.plugin=function(name){if(!(act.name=name))return act.err();var tmp=[name];\"~\"!==name[0]&&(tmp[1]=\"~\"+name,tmp[2]=\"~@\"+name);act.b(tmp)};if(pair$jscomp$0)if(pair$jscomp$0.priv&&pair$jscomp$0.epriv)act.g(pair$jscomp$0);else root.get(\"~\"+pair$jscomp$0.pub).once(act.h);else if(alias)root.get(\"~@\"+alias).once(act.a);else alias||\npass||SEA.name(act.plugin);return gun}})(USE,\"./auth\");USE(function(module){module=USE(\"./user\");var SEA=module.SEA;module.prototype.recall=function(opt,cb){var root=this.back(-1);if((opt=opt||{},opt.sessionStorage)&&SEA.window)try{var sS={};if(sS=SEA.window.sessionStorage)root._.opt.remember=!0,(this.back(\"user\")._.opt||opt).remember=!0,(sS.recall||sS.pair)&&root.user().auth(JSON.parse(sS.pair),cb)}catch(e){}return this}})(USE,\"./recall\");USE(function(module){var User=USE(\"./user\"),SEA=User.SEA,\nGun=User.GUN,noop=function(){};User.prototype.pair=function(){var user=this;try{var proxy=new Proxy({DANGER:\"☠\"},{get:function(t,p,r){if(user.is&&(user._||\"\").sea)return user._.sea[p]}})}catch(e){}return proxy};User.prototype.delete=async function(alias,pass,cb){console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");this.back(-1);var user=this.back(\"user\");try{user.auth(alias,pass,function(ack){user.map().once(function(){this.put(null)});user.leave();(cb||noop)({ok:0})})}catch(e){Gun.log(\"User.delete failed! Error:\",\ne)}return this};User.prototype.alive=async function(){console.log(\"user.alive() IS DEPRECATED!!!\");const gunRoot=this.back(-1);try{return await authRecall(gunRoot),gunRoot._.user._}catch(e){throw Gun.log(\"No session!\"),{err:\"No session!\"};}};User.prototype.trust=async function(user){console.log(\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");Gun.is(user)&&user.get(\"pub\").get((ctx,ev)=>{console.log(ctx,ev)});user.get(\"trust\").get(path).put(theirPubkey)};User.prototype.grant=function(to,\ncb){console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");var user=this.back(-1).user(),pair=user._.sea,path=\"\";this.back(function(at){at.is||(path+=at.get||\"\")});(async function(){var sec=await user.get(\"grant\").get(pair.pub).get(path).then();sec=await SEA.decrypt(sec,pair);if(!sec){sec=SEA.random(16).toString();var enc=await SEA.encrypt(sec,pair);user.get(\"grant\").get(pair.pub).get(path).put(enc)}var pub=to.get(\"pub\").then();enc=to.get(\"epub\").then();pub=await pub;enc=await enc;\nenc=await SEA.secret(enc,pair);enc=await SEA.encrypt(sec,enc);user.get(\"grant\").get(pub).get(path).put(enc,cb)})();return this};User.prototype.secret=function(data,cb){console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");var gun=this,user=gun.back(-1).user(),pair=user.pair(),path=\"\";gun.back(function(at){at.is||(path+=at.get||\"\")});(async function(){var sec=await user.get(\"trust\").get(pair.pub).get(path).then();sec=await SEA.decrypt(sec,pair);if(!sec){sec=SEA.random(16).toString();\nvar enc=await SEA.encrypt(sec,pair);user.get(\"trust\").get(pair.pub).get(path).put(enc)}enc=await SEA.encrypt(data,sec);gun.put(enc,cb)})();return gun};module.exports=User})(USE,\"./share\");USE(function(module){function check(msg){var eve=this,at=eve.as,put=msg.put,soul=put[\"#\"],key=put[\".\"],val=put[\":\"],state=put[\"\\x3e\"],id=msg[\"#\"],tmp;if(soul&&key)if((msg._||\"\").faith&&(at.opt||\"\").faith&&\"function\"==typeof msg._)SEA.opt.pack(put,function(raw){SEA.verify(raw,!1,function(data){put[\"\\x3d\"]=SEA.opt.unpack(data);\neve.to.next(msg)})});else{var no=function(why){at.on(\"in\",{\"@\":id,err:msg.err=why})};(msg._||\"\").DBG&&((msg._||\"\").DBG.c=+new Date);if(0<=soul.indexOf(\"\\x3c?\")&&(tmp=parseFloat(soul.split(\"\\x3c?\")[1]||\"\"))&&state<Gun.state()-1E3*tmp){(tmp=msg._)&&tmp.stun&&tmp.stun--;return}\"~@\"===soul?check.alias(eve,msg,val,key,soul,at,no):\"~@\"===soul.slice(0,2)?check.pubs(eve,msg,val,key,soul,at,no):(tmp=SEA.opt.pub(soul))?check.pub(eve,msg,val,key,soul,at,no,at.user||\"\",tmp):0<=soul.indexOf(\"#\")?check.hash(eve,\nmsg,val,key,soul,at,no):check.any(eve,msg,val,key,soul,at,no,at.user||\"\")}}var SEA=USE(\"./sea\"),S=USE(\"./settings\"),Gun=(SEA.window||\"\").GUN||USE((\"undefined\"===typeof MODULE?\".\":\"\")+\"./gun\",1);Gun.on(\"opt\",function(at){at.sea||(at.sea={own:{}},at.on(\"put\",check,at));this.to.next(at)});check.hash=function(eve,msg,val,key,soul,at,no){SEA.work(val,null,function(data){if(data&&data===key.split(\"#\").slice(-1)[0])return eve.to.next(msg);var JSCompiler_temp;if(JSCompiler_temp=data){JSCompiler_temp=key.split(\"#\").slice(-1)[0];\nlet base64=\"\";for(let i=0;i<JSCompiler_temp.length;i++)base64+=i-1&1?\"\":String.fromCharCode(parseInt(JSCompiler_temp.substring(i-1,i+1),16));JSCompiler_temp=btoa(base64);JSCompiler_temp=data===JSCompiler_temp}if(JSCompiler_temp)return eve.to.next(msg);no(\"Data hash not same as hash!\")},{name:\"SHA-256\"})};check.alias=function(eve,msg,val,key,soul,at,no){if(!val)return no(\"Data must exist!\");if(\"~@\"+key===link_is(val))return eve.to.next(msg);no(\"Alias not same!\")};check.pubs=function(eve,msg,val,key,\nsoul,at,no){if(!val)return no(\"Alias must exist!\");if(key===link_is(val))return eve.to.next(msg);no(\"Alias not same!\")};check.pub=async function(eve,msg,val,key,soul,at,no,user,pub){var tmp$jscomp$0;const raw=await S.parse(val)||{},verify=(certificate,certificant,cb)=>{if(certificate.m&&certificate.s&&certificant&&pub)return SEA.verify(certificate,pub,data=>{if(void 0!==data&&void 0!==data.e&&msg.put[\"\\x3e\"]&&msg.put[\"\\x3e\"]>parseFloat(data.e))return no(\"Certificate expired.\");if(void 0!==data&&data.c&&\ndata.w&&(data.c===certificant||-1<data.c.indexOf(\"*\"))){var path=-1<soul.indexOf(\"/\")?soul.replace(soul.substring(0,soul.indexOf(\"/\")+1),\"\"):\"\";String.match=String.match||Gun.text.match;const w=Array.isArray(data.w)?data.w:\"object\"===typeof data.w||\"string\"===typeof data.w?[data.w]:[];for(const lex of w)if(String.match(path,lex[\"#\"])&&String.match(key,lex[\".\"])||!lex[\".\"]&&String.match(path,lex[\"#\"])||!lex[\"#\"]&&String.match(key,lex[\".\"])||String.match(path?path+\"/\"+key:key,lex[\"#\"]||lex))return lex[\"+\"]&&\n-1<lex[\"+\"].indexOf(\"*\")&&path&&-1==path.indexOf(certificant)&&-1==key.indexOf(certificant)?no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`):data.wb&&(\"string\"===typeof data.wb||(data.wb||{})[\"#\"])?(path=eve.as.root.$.back(-1),\"string\"===typeof data.wb&&\"~\"!==data.wb.slice(0,1)&&(path=path.get(\"~\"+pub)),path.get(data.wb).get(certificant).once(value=>!value||1!==value&&!0!==value?cb(data):no(`Certificant ${certificant} blocked.`))):cb(data);return no(\"Certificate verification fail.\")}})};\nif(\"pub\"===key&&\"~\"+pub===soul)return val===pub?eve.to.next(msg):no(\"Account not same!\");(tmp$jscomp$0=user.is)&&tmp$jscomp$0.pub&&!raw[\"*\"]&&!raw[\"+\"]&&(pub===tmp$jscomp$0.pub||pub!==tmp$jscomp$0.pub&&((msg._.msg||{}).opt||{}).cert)?SEA.opt.pack(msg.put,packed=>{SEA.sign(packed,user._.sea,async function(data){if(void 0===data)return no(SEA.err||\"Signature fail.\");msg.put[\":\"]={\":\":tmp$jscomp$0=SEA.opt.unpack(data.m),\"~\":data.s};msg.put[\"\\x3d\"]=tmp$jscomp$0;if(pub===user.is.pub){if(tmp$jscomp$0=link_is(val))(at.sea.own[tmp$jscomp$0]=\nat.sea.own[tmp$jscomp$0]||{})[pub]=1;JSON.stringifyAsync(msg.put[\":\"],function(err,s){if(err)return no(err||\"Stringify error.\");msg.put[\":\"]=s;return eve.to.next(msg)})}else if(pub!==user.is.pub&&((msg._.msg||{}).opt||{}).cert){const cert=await S.parse(msg._.msg.opt.cert);cert&&cert.m&&cert.s&&verify(cert,user.is.pub,_=>{msg.put[\":\"][\"+\"]=cert;msg.put[\":\"][\"*\"]=user.is.pub;JSON.stringifyAsync(msg.put[\":\"],function(err,s){if(err)return no(err||\"Stringify error.\");msg.put[\":\"]=s;return eve.to.next(msg)})})}},\n{raw:1})}):SEA.opt.pack(msg.put,packed=>{SEA.verify(packed,raw[\"*\"]||pub,function(data){var tmp;data=SEA.opt.unpack(data);if(void 0===data)return no(\"Unverified data.\");(tmp=link_is(data))&&pub===SEA.opt.pub(tmp)&&((at.sea.own[tmp]=at.sea.own[tmp]||{})[pub]=1);if(raw[\"+\"]&&raw[\"+\"].m&&raw[\"+\"].s&&raw[\"*\"])verify(raw[\"+\"],raw[\"*\"],_=>{msg.put[\"\\x3d\"]=data;return eve.to.next(msg)});else return msg.put[\"\\x3d\"]=data,eve.to.next(msg)})})};check.any=function(eve,msg$jscomp$0,val,key,soul,at,no,user){if(at.opt.secure)return no(\"Soul missing public key at '\"+\nkey+\"'.\");at.on(\"secure\",function(msg){this.off();if(!at.opt.secure)return eve.to.next(msg);no(\"Data cannot be changed.\")}).on.on(\"secure\",msg$jscomp$0)};var valid=Gun.valid,link_is=function(d,l){return\"string\"==typeof(l=valid(d))&&l},pubcut=/[^\\w_-]/;SEA.opt.pub=function(s){if(s&&(s=s.split(\"~\"))&&(s=s[1])&&(s=s.split(pubcut).slice(0,2))&&2==s.length&&\"@\"!==(s[0]||\"\")[0])return s=s.slice(0,2).join(\".\")};SEA.opt.stringy=function(t){};SEA.opt.pack=function(d,cb,k,n,s){if(SEA.opt.check(d))return cb(d);\nif(d&&d[\"#\"]&&d[\".\"]&&d[\"\\x3e\"]){var tmp=d[\":\"];var f=1}JSON.parseAsync(f?tmp:d,function(err,meta){(err=void 0!==(meta||\"\")[\":\"]&&(meta||\"\")[\"~\"])?cb({m:{\"#\":s||d[\"#\"],\".\":k||d[\".\"],\":\":(meta||\"\")[\":\"],\"\\x3e\":d[\"\\x3e\"]||Gun.state.is(n,k)},s:err}):cb(d)})};var O=SEA.opt;SEA.opt.unpack=function(d,k,n){var tmp;if(void 0!==d){if(d&&void 0!==(tmp=d[\":\"]))return tmp;k=k||O.fall_key;!n&&O.fall_val&&(n={},n[k]=O.fall_val);if(k&&n){if(d===n[k]||!SEA.opt.check(n[k]))return d;tmp=n&&n._&&n._[\"#\"]||O.fall_soul;\nn=Gun.state.is(n,k)||O.fall_state;if(d&&4===d.length&&tmp===d[0]&&k===d[1]&&fl(n)===fl(d[3]))return d[2];if(n<SEA.opt.shuffle_attack)return d}}};SEA.opt.shuffle_attack=15463296E5;var fl=Math.floor})(USE,\"./index\")})()}","~:source","shadow$provide[\"module$node_modules$gun$sea\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n;(function(){\n\n  /* UNBUILD */\n  function USE(arg, req){\n    return req? require(arg) : arg.slice? USE[R(arg)] : function(mod, path){\n      arg(mod = {exports: {}});\n      USE[R(path)] = mod.exports;\n    }\n    function R(p){\n      return p.split('/').slice(-1).toString().replace('.js','');\n    }\n  }\n  if(typeof module !== \"undefined\"){ var MODULE = module }\n  /* UNBUILD */\n\n  ;USE(function(module){\n    // Security, Encryption, and Authorization: SEA.js\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\n    // THIS IS AN EARLY ALPHA!\n\n    if(typeof self !== \"undefined\"){ module.window = self } // should be safe for at least browser/worker/nodejs, need to check other envs like RN etc.\n    if(typeof window !== \"undefined\"){ module.window = window }\n\n    var tmp = module.window || module, u;\n    var SEA = tmp.SEA || {};\n\n    if(SEA.window = module.window){ SEA.window.SEA = SEA }\n\n    try{ if(u+'' !== typeof MODULE){ MODULE.exports = SEA } }catch(e){}\n    module.exports = SEA;\n  })(USE, './root');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    try{ if(SEA.window){\n      if(location.protocol.indexOf('s') < 0\n      && location.host.indexOf('localhost') < 0\n      && ! /^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname)\n      && location.protocol.indexOf('file:') < 0){\n        console.warn('HTTPS needed for WebCrypto in SEA, redirecting...');\n        location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\n      }\n    } }catch(e){}\n  })(USE, './https');\n\n  ;USE(function(module){\n    var u;\n    if(u+''== typeof btoa){\n      if(u+'' == typeof Buffer){\n        try{ global.Buffer = USE(\"buffer\", 1).Buffer }catch(e){ console.log(\"Please `npm install buffer` or add it to your package.json !\") }\n      }\n      global.btoa = function(data){ return Buffer.from(data, \"binary\").toString(\"base64\") };\n      global.atob = function(data){ return Buffer.from(data, \"base64\").toString(\"binary\") };\n    }\n  })(USE, './base64');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\n    function SeaArray() {}\n    Object.assign(SeaArray, { from: Array.from })\n    SeaArray.prototype = Object.create(Array.prototype)\n    SeaArray.prototype.toString = function(enc, start, end) { enc = enc || 'utf8'; start = start || 0;\n      const length = this.length\n      if (enc === 'hex') {\n        const buf = new Uint8Array(this)\n        return [ ...Array(((end && (end + 1)) || length) - start).keys()]\n        .map((i) => buf[ i + start ].toString(16).padStart(2, '0')).join('')\n      }\n      if (enc === 'utf8') {\n        return Array.from(\n          { length: (end || length) - start },\n          (_, i) => String.fromCharCode(this[ i + start])\n        ).join('')\n      }\n      if (enc === 'base64') {\n        return btoa(this)\n      }\n    }\n    module.exports = SeaArray;\n  })(USE, './array');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Buffer implementation used in SEA. Functionality is mostly\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\n    // between binary and 'hex' | 'utf8' | 'base64'\n    // See documentation and validation for safe implementation in:\n    // https://github.com/feross/safe-buffer#update\n    var SeaArray = USE('./array');\n    function SafeBuffer(...props) {\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()')\n      return SafeBuffer.from(...props)\n    }\n    SafeBuffer.prototype = Object.create(Array.prototype)\n    Object.assign(SafeBuffer, {\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\n      from() {\n        if (!Object.keys(arguments).length || arguments[0]==null) {\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n        }\n        const input = arguments[0]\n        let buf\n        if (typeof input === 'string') {\n          const enc = arguments[1] || 'utf8'\n          if (enc === 'hex') {\n            const bytes = input.match(/([\\da-fA-F]{2})/g)\n            .map((byte) => parseInt(byte, 16))\n            if (!bytes || !bytes.length) {\n              throw new TypeError('Invalid first argument for type \\'hex\\'.')\n            }\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'utf8' || 'binary' === enc) { // EDIT BY MARK: I think this is safe, tested it against a couple \"binary\" strings. This lets SafeBuffer match NodeJS Buffer behavior more where it safely btoas regular strings.\n            const length = input.length\n            const words = new Uint16Array(length)\n            Array.from({ length: length }, (_, i) => words[i] = input.charCodeAt(i))\n            buf = SeaArray.from(words)\n          } else if (enc === 'base64') {\n            const dec = atob(input)\n            const length = dec.length\n            const bytes = new Uint8Array(length)\n            Array.from({ length: length }, (_, i) => bytes[i] = dec.charCodeAt(i))\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'binary') { // deprecated by above comment\n            buf = SeaArray.from(input) // some btoas were mishandled.\n          } else {\n            console.info('SafeBuffer.from unknown encoding: '+enc)\n          }\n          return buf\n        }\n        const byteLength = input.byteLength // what is going on here? FOR MARTTI\n        const length = input.byteLength ? input.byteLength : input.length\n        if (length) {\n          let buf\n          if (input instanceof ArrayBuffer) {\n            buf = new Uint8Array(input)\n          }\n          return SeaArray.from(buf || input)\n        }\n      },\n      // This is 'safe-buffer.alloc' sans encoding support\n      alloc(length, fill = 0 /*, enc*/ ) {\n        return SeaArray.from(new Uint8Array(Array.from({ length: length }, () => fill)))\n      },\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\n      allocUnsafe(length) {\n        return SeaArray.from(new Uint8Array(Array.from({ length : length })))\n      },\n      // This puts together array of array like members\n      concat(arr) { // octet array\n        if (!Array.isArray(arr)) {\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.')\n        }\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []))\n      }\n    })\n    SafeBuffer.prototype.from = SafeBuffer.from\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString\n\n    module.exports = SafeBuffer;\n  })(USE, './buffer');\n\n  ;USE(function(module){\n    const SEA = USE('./root')\n    const api = {Buffer: USE('./buffer')}\n    var o = {}, u;\n\n    // ideally we can move away from JSON entirely? unlikely due to compatibility issues... oh well.\n    JSON.parseAsync = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\n    JSON.stringifyAsync = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\n\n    api.parse = function(t,r){ return new Promise(function(res, rej){\n      JSON.parseAsync(t,function(err, raw){ err? rej(err) : res(raw) },r);\n    })}\n    api.stringify = function(v,r,s){ return new Promise(function(res, rej){\n      JSON.stringifyAsync(v,function(err, raw){ err? rej(err) : res(raw) },r,s);\n    })}\n\n    if(SEA.window){\n      api.crypto = SEA.window.crypto || SEA.window.msCrypto\n      api.subtle = (api.crypto||o).subtle || (api.crypto||o).webkitSubtle;\n      api.TextEncoder = SEA.window.TextEncoder;\n      api.TextDecoder = SEA.window.TextDecoder;\n      api.random = (len) => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len))));\n    }\n    if(!api.TextDecoder)\n    {\n      const { TextEncoder, TextDecoder } = USE((u+'' == typeof MODULE?'.':'')+'./lib/text-encoding', 1);\n      api.TextDecoder = TextDecoder;\n      api.TextEncoder = TextEncoder;\n    }\n    if(!api.crypto)\n    {\n      try\n      {\n      var crypto = USE('crypto', 1);\n      Object.assign(api, {\n        crypto,\n        random: (len) => api.Buffer.from(crypto.randomBytes(len))\n      });      \n      const { Crypto: WebCrypto } = USE('@peculiar/webcrypto', 1);\n      api.ossl = api.subtle = new WebCrypto({directory: 'ossl'}).subtle // ECDH\n    }\n    catch(e){\n      console.log(\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\");\n    }}\n\n    module.exports = api\n  })(USE, './shim');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var s = {};\n    s.pbkdf2 = {hash: {name : 'SHA-256'}, iter: 100000, ks: 64};\n    s.ecdsa = {\n      pair: {name: 'ECDSA', namedCurve: 'P-256'},\n      sign: {name: 'ECDSA', hash: {name: 'SHA-256'}}\n    };\n    s.ecdh = {name: 'ECDH', namedCurve: 'P-256'};\n\n    // This creates Web Cryptography API compliant JWK for sign/verify purposes\n    s.jwk = function(pub, d){  // d === priv\n      pub = pub.split('.');\n      var x = pub[0], y = pub[1];\n      var jwk = {kty: \"EC\", crv: \"P-256\", x: x, y: y, ext: true};\n      jwk.key_ops = d ? ['sign'] : ['verify'];\n      if(d){ jwk.d = d }\n      return jwk;\n    };\n    \n    s.keyToJwk = function(keyBytes) {\n      const keyB64 = keyBytes.toString('base64');\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n      return { kty: 'oct', k: k, ext: false, alg: 'A256GCM' };\n    }\n\n    s.recall = {\n      validity: 12 * 60 * 60, // internally in seconds : 12 hours\n      hook: function(props){ return props } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\n    };\n\n    s.check = function(t){ return (typeof t == 'string') && ('SEA{' === t.slice(0,4)) }\n    s.parse = async function p(t){ try {\n      var yes = (typeof t == 'string');\n      if(yes && 'SEA{' === t.slice(0,4)){ t = t.slice(3) }\n      return yes ? await shim.parse(t) : t;\n      } catch (e) {}\n      return t;\n    }\n\n    SEA.opt = s;\n    module.exports = s\n  })(USE, './settings');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    module.exports = async function(d, o){\n      var t = (typeof d == 'string')? d : await shim.stringify(d);\n      var hash = await shim.subtle.digest({name: o||'SHA-256'}, new shim.TextEncoder().encode(t));\n      return shim.Buffer.from(hash);\n    }\n  })(USE, './sha256');\n\n  ;USE(function(module){\n    // This internal func returns SHA-1 hashed data for KeyID generation\n    const __shim = USE('./shim')\n    const subtle = __shim.subtle\n    const ossl = __shim.ossl ? __shim.ossl : subtle\n    const sha1hash = (b) => ossl.digest({name: 'SHA-1'}, new ArrayBuffer(b))\n    module.exports = sha1hash\n  })(USE, './sha1');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => { try { // used to be named `proof`\n      var salt = (pair||{}).epub || pair; // epub not recommended, salt should be random!\n      opt = opt || {};\n      if(salt instanceof Function){\n        cb = salt;\n        salt = u;\n      }\n      data = (typeof data == 'string')? data : await shim.stringify(data);\n      if('sha' === (opt.name||'').toLowerCase().slice(0,3)){\n        var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64')\n        if(cb){ try{ cb(rsha) }catch(e){console.log(e)} }\n        return rsha;\n      }\n      salt = salt || shim.random(9);\n      var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {name: opt.name || 'PBKDF2'}, false, ['deriveBits']);\n      var work = await (shim.ossl || shim.subtle).deriveBits({\n        name: opt.name || 'PBKDF2',\n        iterations: opt.iterations || S.pbkdf2.iter,\n        salt: new shim.TextEncoder().encode(opt.salt || salt),\n        hash: opt.hash || S.pbkdf2.hash,\n      }, key, opt.length || (S.pbkdf2.ks * 8))\n      data = shim.random(data.length)  // Erase data in case of passphrase\n      var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64')\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.work;\n  })(USE, './work');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n\n    SEA.name = SEA.name || (async (cb, opt) => { try {\n      if(cb){ try{ cb() }catch(e){console.log(e)} }\n      return;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    //SEA.pair = async (data, proof, cb) => { try {\n    SEA.pair = SEA.pair || (async (cb, opt) => { try {\n\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      // First: ECDSA keys for signing/verifying...\n      var sa = await shim.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, [ 'sign', 'verify' ])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\n        var key = {};\n        key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await shim.subtle.exportKey('jwk', keys.publicKey);\n        //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\n        key.pub = pub.x+'.'+pub.y; // new\n        // x and y are already base64\n        // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      \n      // To include PGPv4 kind of keyId:\n      // const pubId = await SEA.keyid(keys.pub)\n      // Next: ECDH keys for encryption/decryption...\n\n      try{\n      var dh = await ecdhSubtle.generateKey({name: 'ECDH', namedCurve: 'P-256'}, true, ['deriveKey'])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        var key = {};\n        key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey);\n        //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\n        key.epub = pub.x+'.'+pub.y; // new\n        // ex and ey are already base64\n        // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      }catch(e){\n        if(SEA.window){ throw e }\n        if(e == 'Error: ECDH is not a supported algorithm'){ console.log('Ignoring ECDH...') }\n        else { throw e }\n      } dh = dh || {};\n\n      var r = { pub: sa.pub, priv: sa.priv, /* pubId, */ epub: dh.epub, epriv: dh.epriv }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.pair;\n  })(USE, './pair');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!(pair||opt).priv){\n        if(!SEA.I){ throw 'No signing key.' }\n        pair = await SEA.I(null, {what: data, how: 'sign', why: opt.why});\n      }\n      if(u === data){ throw '`undefined` not allowed.' }\n      var json = await S.parse(data);\n      var check = opt.check = opt.check || json;\n      if(SEA.verify && (SEA.opt.check(check) || (check && check.s && check.m))\n      && u !== await SEA.verify(check, pair)){ // don't sign if we already signed it.\n        var r = await S.parse(check);\n        if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n        if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n        return r;\n      }\n      var pub = pair.pub;\n      var priv = pair.priv;\n      var jwk = S.jwk(pub, priv);\n      var hash = await sha(json);\n      var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, ['sign'])\n      .then((key) => (shim.ossl || shim.subtle).sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, new Uint8Array(hash))) // privateKey scope doesn't leak out from here!\n      var r = {m: json, s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')}\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.sign;\n  })(USE, './sign');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => { try {\n      var json = await S.parse(data);\n      if(false === pair){ // don't verify!\n        var raw = await S.parse(json.m);\n        if(cb){ try{ cb(raw) }catch(e){console.log(e)} }\n        return raw;\n      }\n      opt = opt || {};\n      // SEA.I // verify is free! Requires no user permission.\n      var pub = pair.pub || pair;\n      var key = SEA.opt.slow_leak? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {name: 'ECDSA', namedCurve: 'P-256'}, false, ['verify']);\n      var hash = await sha(json.m);\n      var buf, sig, check, tmp; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash));\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){\n        if(SEA.opt.fallback){\n          return await SEA.opt.fall_verify(data, pair, cb, opt);\n        }\n      }\n      var r = check? await S.parse(json.m) : u;\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e); // mismatched owner FOR MARTTI\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.verify;\n    // legacy & ossl memory leak mitigation:\n\n    var knownKeys = {};\n    var keyForPair = SEA.opt.slow_leak = pair => {\n      if (knownKeys[pair]) return knownKeys[pair];\n      var jwk = S.jwk(pair);\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, [\"verify\"]);\n      return knownKeys[pair];\n    };\n\n    var O = SEA.opt;\n    SEA.opt.fall_verify = async function(data, pair, cb, opt, f){\n      if(f === SEA.opt.fallback){ throw \"Signature did not match\" } f = f || 1;\n      var tmp = data||'';\n      data = SEA.opt.unpack(data) || data;\n      var json = await S.parse(data), pub = pair.pub || pair, key = await SEA.opt.slow_leak(pub);\n      var hash = (f <= SEA.opt.fallback)? shim.Buffer.from(await shim.subtle.digest({name: 'SHA-256'}, new shim.TextEncoder().encode(await S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\n      var buf; var sig; var check; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64') // NEW DEFAULT!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){ try{\n        buf = shim.Buffer.from(json.s, 'utf8') // AUTO BACKWARD OLD UTF8 DATA!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        }catch(e){\n        if(!check){ throw \"Signature did not match.\" }\n        }\n      }\n      var r = check? await S.parse(json.m) : u;\n      O.fall_soul = tmp['#']; O.fall_key = tmp['.']; O.fall_val = data; O.fall_state = tmp['>'];\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    }\n    SEA.opt.fallback = 2;\n\n  })(USE, './verify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha256hash = USE('./sha256');\n\n    const importGen = async (key, salt, opt) => {\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\n      opt = opt || {};\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary')\n      \n      const jwkKey = S.keyToJwk(hash)      \n      return await shim.subtle.importKey('jwk', jwkKey, {name:'AES-GCM'}, false, ['encrypt', 'decrypt'])\n    }\n    module.exports = importGen;\n  })(USE, './aeskey');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n    var u;\n\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(u === data){ throw '`undefined` not allowed.' }\n      if(!key){\n        if(!SEA.I){ throw 'No encryption key.' }\n        pair = await SEA.I(null, {what: data, how: 'encrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var msg = (typeof data == 'string')? data : await shim.stringify(data);\n      var rand = {s: shim.random(9), iv: shim.random(15)}; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\n      var ct = await aeskey(key, rand.s, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).encrypt({ // Keeping the AES key scope as private as possible...\n        name: opt.name || 'AES-GCM', iv: new Uint8Array(rand.iv)\n      }, aes, new shim.TextEncoder().encode(msg)));\n      var r = {\n        ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\n        iv: rand.iv.toString(opt.encode || 'base64'),\n        s: rand.s.toString(opt.encode || 'base64')\n      }\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.encrypt;\n  })(USE, './encrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(!key){\n        if(!SEA.I){ throw 'No decryption key.' }\n        pair = await SEA.I(null, {what: data, how: 'decrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var json = await S.parse(data);\n      var buf, bufiv, bufct; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64');\n        bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\n        bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\n        var ct = await aeskey(key, buf, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).decrypt({  // Keeping aesKey scope as private as possible...\n          name: opt.name || 'AES-GCM', iv: new Uint8Array(bufiv), tagLength: 128\n        }, aes, new Uint8Array(bufct)));\n      }catch(e){\n        if('utf8' === opt.encode){ throw \"Could not decrypt\" }\n        if(SEA.opt.fallback){\n          opt.encode = 'utf8';\n          return await SEA.decrypt(data, pair, cb, opt);\n        }\n      }\n      var r = await S.parse(new shim.TextDecoder('utf8').decode(ct));\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.decrypt;\n  })(USE, './decrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    // Derive shared secret from other's pub and my epub/epriv \n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!pair || !pair.epriv || !pair.epub){\n        if(!SEA.I){ throw 'No secret mix.' }\n        pair = await SEA.I(null, {what: key, how: 'secret', why: opt.why});\n      }\n      var pub = key.epub || key;\n      var epub = pair.epub;\n      var epriv = pair.epriv;\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      var pubKeyData = keysToEcdhJwk(pub);\n      var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) },{name: 'ECDH', namedCurve: 'P-256'}); // Thanks to @sirpy !\n      var privKeyData = keysToEcdhJwk(epub, epriv);\n      var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async (privKey) => {\n        // privateKey scope doesn't leak out from here!\n        var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\n        var rawBits = new Uint8Array(derivedBits);\n        var derivedKey = await ecdhSubtle.importKey('raw', rawBits,{ name: 'AES-GCM', length: 256 }, true, [ 'encrypt', 'decrypt' ]);\n        return ecdhSubtle.exportKey('jwk', derivedKey).then(({ k }) => k);\n      })\n      var r = derived;\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    // can this be replaced with settings.jwk?\n    var keysToEcdhJwk = (pub, d) => { // d === priv\n      //var [ x, y ] = shim.Buffer.from(pub, 'base64').toString('utf8').split(':') // old\n      var [ x, y ] = pub.split('.') // new\n      var jwk = d ? { d: d } : {}\n      return [  // Use with spread returned value...\n        'jwk',\n        Object.assign(\n          jwk,\n          { x: x, y: y, kty: 'EC', crv: 'P-256', ext: true }\n        ), // ??? refactor\n        {name: 'ECDH', namedCurve: 'P-256'}\n      ]\n    }\n\n    module.exports = SEA.secret;\n  })(USE, './secret');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => { try {\n      /*\n      The Certify Protocol was made out of love by a Vietnamese code enthusiast. Vietnamese people around the world deserve respect!\n      IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\n      \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\n      \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\n      \"authority\": Key pair or priv of the certificate authority.\n      \"cb\": A callback function after all things are done.\n      \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.block is set, SEA will look for block before syncing.\n      */\n      console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.')\n\n      certificants = (() => {\n        var data = []\n        if (certificants) {\n          if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') > -1) return '*'\n          if (typeof certificants === 'string') return certificants\n          if (Array.isArray(certificants)) {\n            if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null\n            certificants.map(certificant => {\n              if (typeof certificant ==='string') data.push(certificant)\n              else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub)\n            })\n          }\n\n          if (typeof certificants === 'object' && certificants.pub) return certificants.pub\n          return data.length > 0 ? data : null\n        }\n        return\n      })()\n\n      if (!certificants) return console.log(\"No certificant found.\")\n\n      const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null\n      const readPolicy = (policy || {}).read ? policy.read : null\n      const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null\n      // The \"blacklist\" feature is now renamed to \"block\". Why ? BECAUSE BLACK LIVES MATTER!\n      // We can now use 3 keys: block, blacklist, ban\n      const block = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {}\n      const readBlock = block.read && (typeof block.read === 'string' || (block.read || {})['#']) ? block.read : null\n      const writeBlock = typeof block === 'string' ? block : block.write && (typeof block.write === 'string' || block.write['#']) ? block.write : null\n\n      if (!readPolicy && !writePolicy) return console.log(\"No policy found.\")\n\n      // reserved keys: c, e, r, w, rb, wb\n      const data = JSON.stringify({\n        c: certificants,\n        ...(expiry ? {e: expiry} : {}), // inject expiry if possible\n        ...(readPolicy ? {r: readPolicy }  : {}), // \"r\" stands for read, which means read permission.\n        ...(writePolicy ? {w: writePolicy} : {}), // \"w\" stands for write, which means write permission.\n        ...(readBlock ? {rb: readBlock} : {}), // inject READ block if possible\n        ...(writeBlock ? {wb: writeBlock} : {}), // inject WRITE block if possible\n      })\n\n      const certificate = await SEA.sign(data, authority, null, {raw:1})\n\n      var r = certificate\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.certify;\n  })(USE, './certify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    // Practical examples about usage found in tests.\n    var SEA = USE('./root');\n    SEA.work = USE('./work');\n    SEA.sign = USE('./sign');\n    SEA.verify = USE('./verify');\n    SEA.encrypt = USE('./encrypt');\n    SEA.decrypt = USE('./decrypt');\n    SEA.certify = USE('./certify');\n    //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\n\n    SEA.random = SEA.random || shim.random;\n\n    // This is Buffer used in SEA and usable from Gun/SEA application also.\n    // For documentation see https://nodejs.org/api/buffer.html\n    SEA.Buffer = SEA.Buffer || USE('./buffer');\n\n    // These SEA functions support now ony Promises or\n    // async/await (compatible) code, use those like Promises.\n    //\n    // Creates a wrapper library around Web Crypto API\n    // for various AES, ECDSA, PBKDF2 functions we called above.\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\n    SEA.keyid = SEA.keyid || (async (pub) => {\n      try {\n        // base64('base64(x):base64(y)') => shim.Buffer(xy)\n        const pb = shim.Buffer.concat(\n          pub.replace(/-/g, '+').replace(/_/g, '/').split('.')\n          .map((t) => shim.Buffer.from(t, 'base64'))\n        )\n        // id is PGPv4 compliant raw key\n        const id = shim.Buffer.concat([\n          shim.Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb\n        ])\n        const sha1 = await sha1hash(id)\n        const hash = shim.Buffer.from(sha1, 'binary')\n        return hash.toString('hex', hash.length - 8)  // 16-bit ID as hex\n      } catch (e) {\n        console.log(e)\n        throw e\n      }\n    });\n    // all done!\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\n    // SEA should be a full suite that is easy and seamless to use.\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\n    // But all other behavior needs to be equally easy, like opinionated ways of\n    // Adding friends (trusted public keys), sending private messages, etc.\n    // Cheers! Tell me what you think.\n    ((SEA.window||{}).GUN||{}).SEA = SEA;\n\n    module.exports = SEA\n    // -------------- END SEA MODULES --------------------\n    // -- BEGIN SEA+GUN MODULES: BUNDLED BY DEFAULT UNTIL OTHERS USE SEA ON OWN -------\n  })(USE, './sea');\n\n  ;USE(function(module){\n    var SEA = USE('./sea'), Gun, u;\n    if(SEA.window){\n      Gun = SEA.window.GUN || {chain:{}};\n    } else {\n      Gun = USE((u+'' == typeof MODULE?'.':'')+'./gun', 1);\n    }\n    SEA.GUN = Gun;\n\n    function User(root){ \n      this._ = {$: this};\n    }\n    User.prototype = (function(){ function F(){}; F.prototype = Gun.chain; return new F() }()) // Object.create polyfill\n    User.prototype.constructor = User;\n\n    // let's extend the gun chain with a `user` function.\n    // only one user can be logged in at a time, per gun instance.\n    Gun.chain.user = function(pub){\n      var gun = this, root = gun.back(-1), user;\n      if(pub){\n        pub = SEA.opt.pub((pub._||'')['#']) || pub;\n        return root.get('~'+pub);\n      }\n      if(user = root.back('user')){ return user }\n      var root = (root._), at = root, uuid = at.opt.uuid || lex;\n      (at = (user = at.user = gun.chain(new User))._).opt = {};\n      at.opt.uuid = function(cb){\n        var id = uuid(), pub = root.user;\n        if(!pub || !(pub = pub.is) || !(pub = pub.pub)){ return id }\n        id = '~' + pub + '/' + id;\n        if(cb && cb.call){ cb(null, id) }\n        return id;\n      }\n      return user;\n    }\n    function lex(){ return Gun.state().toString(36).replace('.','') }\n    Gun.User = User;\n    User.GUN = Gun;\n    User.SEA = Gun.SEA = SEA;\n    module.exports = User;\n  })(USE, './user');\n\n  ;USE(function(module){\n    var u, Gun = (''+u != typeof GUN)? (GUN||{chain:{}}) : USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\n    Gun.chain.then = function(cb, opt){\n      var gun = this, p = (new Promise(function(res, rej){\n        gun.once(res, opt);\n      }));\n      return cb? p.then(cb) : p;\n    }\n  })(USE, './then');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n\n    // Well first we have to actually create a user. That is what this function does.\n    User.prototype.create = function(...args){\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\n      var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      cb = cb || noop;\n      opt = opt || {};\n      if(false !== opt.check){\n        var err;\n        if(!alias){ err = \"No user.\" }\n        if((pass||'').length < 8){ err = \"Password too short!\" }\n        if(err){\n          cb({err: Gun.log(err)});\n          return gun;\n        }\n      }\n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      var act = {}, u;\n      act.a = function(pubs){\n        act.pubs = pubs;\n        if(pubs && !opt.already){\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\n          var ack = {err: Gun.log('User already created!')};\n          cat.ing = false;\n          (cb || noop)(ack);\n          gun.leave();\n          return;\n        }\n        act.salt = String.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\n      }\n      act.b = function(proof){\n        act.proof = proof;\n        pair ? act.c(pair) : SEA.pair(act.c) // generate a brand new key pair or use the existing.\n      }\n      act.c = function(pair){\n        var tmp\n        act.pair = pair || {};\n        if(tmp = cat.root.user){\n          tmp._.sea = pair;\n          tmp.is = {pub: pair.pub, epub: pair.epub, alias: alias};\n        }\n        // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\n        act.data = {pub: pair.pub};\n        act.d();\n      }\n      act.d = function(){\n        act.data.alias = alias;\n        act.e();\n      }\n      act.e = function(){\n        act.data.epub = act.pair.epub; \n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, act.proof, act.f, {raw:1}); // to keep the private key safe, we AES encrypt it with the proof of work!\n      }\n      act.f = function(auth){\n        act.data.auth = JSON.stringify({ek: auth, s: act.salt}); \n        act.g(act.data.auth);\n      }\n      act.g = function(auth){ var tmp;\n        act.data.auth = act.data.auth || auth;\n        root.get(tmp = '~'+act.pair.pub).put(act.data).on(act.h); // awesome, now we can actually save the user with their public key as their ID.\n        var link = {}; link[tmp] = {'#': tmp}; root.get('~@'+alias).put(link).get(tmp).on(act.i); // next up, we want to associate the alias with the public key. So we add it to the alias list.\n      }\n      act.h = function(data, key, msg, eve){\n        eve.off(); act.h.ok = 1; act.i();\n      }\n      act.i = function(data, key, msg, eve){\n        if(eve){ act.i.ok = 1; eve.off() }\n        if(!act.h.ok || !act.i.ok){ return }\n        cat.ing = false;\n        cb({ok: 0, pub: act.pair.pub}); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\n        if(noop === cb){ pair ? gun.auth(pair) : gun.auth(alias, pass) } // if no callback is passed, auto-login after signing up.\n      }\n      root.get('~@'+alias).once(act.a);\n      return gun;\n    }\n    User.prototype.leave = function(opt, cb){\n      var gun = this, user = (gun.back(-1)._).user;\n      if(user){\n        delete user.is;\n        delete user._.is;\n        delete user._.sea;\n      }\n      if(SEA.window){\n        try{var sS = {};\n        sS = SEA.window.sessionStorage;\n        delete sS.recall;\n        delete sS.pair;\n        }catch(e){};\n      }\n      return gun;\n    }\n  })(USE, './create');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n    // now that we have created a user, we want to authenticate them!\n    User.prototype.auth = function(...args){ // TODO: this PR with arguments need to be cleaned up / refactored.\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = !pair && typeof args[0] === 'string' ? args[0] : null;\n      var pass = (alias || (pair && !(pair.priv && pair.epriv))) && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      \n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      \n      var act = {}, u, tries = 9;\n      act.a = function(data){\n        if(!data){ return act.b() }\n        if(!data.pub){\n          var tmp = []; Object.keys(data).forEach(function(k){ if('_'==k){ return } tmp.push(data[k]) })\n          return act.b(tmp);\n        }\n        if(act.name){ return act.f(data) }\n        act.c((act.data = data).auth);\n      }\n      act.b = function(list){\n        var get = (act.list = (act.list||[]).concat(list||[])).shift();\n        if(u === get){\n          if(act.name){ return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.') }\n          if(alias && tries--){\n            root.get('~@'+alias).once(act.a);\n            return;\n          }\n          return act.err('Wrong user or password.') \n        }\n        root.get(get).once(act.a);\n      }\n      act.c = function(auth){\n        if(u === auth){ return act.b() }\n        if('string' == typeof auth){ return act.c(obj_ify(auth)) } // in case of legacy\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\n      }\n      act.d = function(proof){\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\n      }\n      act.e = function(half){\n        if(u === half){\n          if(!act.enc){ // try old format\n            act.enc = {encode: 'utf8'};\n            return act.c(act.auth);\n          } act.enc = null; // end backwards\n          return act.b();\n        }\n        act.half = half;\n        act.f(act.data);\n      }\n      act.f = function(pair){\n        var half = act.half || {}, data = act.data || {};\n        act.g(act.lol = {pub: pair.pub || data.pub, epub: pair.epub || data.epub, priv: pair.priv || half.priv, epriv: pair.epriv || half.epriv});\n      }\n      act.g = function(pair){\n        if(!pair || !pair.pub || !pair.epub){ return act.b() }\n        act.pair = pair;\n        var user = (root._).user, at = (user._);\n        var tmp = at.tag;\n        var upt = at.opt;\n        at = user._ = root.get('~'+pair.pub)._;\n        at.opt = upt;\n        // add our credentials in-memory only to our root user instance\n        user.is = {pub: pair.pub, epub: pair.epub, alias: alias || pair.pub};\n        at.sea = act.pair;\n        cat.ing = false;\n        try{if(pass && u == (obj_ify(cat.root.graph['~'+pair.pub].auth)||'')[':']){ opt.shuffle = opt.change = pass; } }catch(e){} // migrate UTF8 & Shuffle!\n        opt.change? act.z() : (cb || noop)(at);\n        if(SEA.window && ((gun.back('user')._).opt||opt).remember){\n          // TODO: this needs to be modular.\n          try{var sS = {};\n          sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n          sS.recall = true;\n          sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\n          }catch(e){}\n        }\n        try{\n          if(root._.tag.auth){ // auth handle might not be registered yet\n          (root._).on('auth', at) // TODO: Deprecate this, emit on user instead! Update docs when you do.\n          } else { setTimeout(function(){ (root._).on('auth', at) },1) } // if not, hackily add a timeout.\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\n        }catch(e){\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\n        }\n      }\n      act.h = function(data){\n        if(!data){ return act.b() }\n        alias = data.alias\n        if(!alias)\n          alias = data.alias = \"~\" + pair.pub        \n        if(!data.auth){\n          return act.g(pair);\n        }\n        pair = null;\n        act.c((act.data = data).auth);\n      }\n      act.z = function(){\n        // password update so encrypt private key using new pwd + salt\n        act.salt = String.random(64); // pseudo-random\n        SEA.work(opt.change, act.salt, act.y);\n      }\n      act.y = function(proof){\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, proof, act.x, {raw:1});\n      }\n      act.x = function(auth){\n        act.w(JSON.stringify({ek: auth, s: act.salt}));\n      }\n      act.w = function(auth){\n        if(opt.shuffle){ // delete in future!\n          console.log('migrate core account from UTF8 & shuffle');\n          var tmp = {}; Object.keys(act.data).forEach(function(k){ tmp[k] = act.data[k] });\n          delete tmp._;\n          tmp.auth = auth;\n          root.get('~'+act.pair.pub).put(tmp);\n        } // end delete\n        root.get('~'+act.pair.pub).get('auth').put(auth, cb || noop);\n      }\n      act.err = function(e){\n        var ack = {err: Gun.log(e || 'User cannot be found!')};\n        cat.ing = false;\n        (cb || noop)(ack);\n      }\n      act.plugin = function(name){\n        if(!(act.name = name)){ return act.err() }\n        var tmp = [name];\n        if('~' !== name[0]){\n          tmp[1] = '~'+name;\n          tmp[2] = '~@'+name;\n        }\n        act.b(tmp);\n      }\n      if(pair){\n        if(pair.priv && pair.epriv)\n          act.g(pair);\n        else\n          root.get('~'+pair.pub).once(act.h);\n      } else\n      if(alias){\n        root.get('~@'+alias).once(act.a);\n      } else\n      if(!alias && !pass){\n        SEA.name(act.plugin);\n      }\n      return gun;\n    }\n    function obj_ify(o){\n      if('string' != typeof o){ return o }\n      try{o = JSON.parse(o);\n      }catch(e){o={}};\n      return o;\n    }\n  })(USE, './auth');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN;\n    User.prototype.recall = function(opt, cb){\n      var gun = this, root = gun.back(-1), tmp;\n      opt = opt || {};\n      if(opt && opt.sessionStorage){\n        if(SEA.window){\n          try{\n            var sS = {};\n            sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n            if(sS){\n              (root._).opt.remember = true;\n              ((gun.back('user')._).opt||opt).remember = true;\n              if(sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\n            }\n          }catch(e){}\n        }\n        return gun;\n      }\n      /*\n        TODO: copy mhelander's expiry code back in.\n        Although, we should check with community,\n        should expiry be core or a plugin?\n      */\n      return gun;\n    }\n  })(USE, './recall');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n    User.prototype.pair = function(){\n      var user = this, proxy; // undeprecated, hiding with proxies.\n      try{ proxy = new Proxy({DANGER:'\\u2620'}, {get: function(t,p,r){\n        if(!user.is || !(user._||'').sea){ return }\n        return user._.sea[p];\n      }})}catch(e){}\n      return proxy;\n    }\n    // If authenticated user wants to delete his/her account, let's support it!\n    User.prototype.delete = async function(alias, pass, cb){\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\n      var gun = this, root = gun.back(-1), user = gun.back('user');\n      try {\n        user.auth(alias, pass, function(ack){\n          var pub = (user.is||{}).pub;\n          // Delete user data\n          user.map().once(function(){ this.put(null) });\n          // Wipe user data from memory\n          user.leave();\n          (cb || noop)({ok: 0});\n        });\n      } catch (e) {\n        Gun.log('User.delete failed! Error:', e);\n      }\n      return gun;\n    }\n    User.prototype.alive = async function(){\n      console.log(\"user.alive() IS DEPRECATED!!!\");\n      const gunRoot = this.back(-1)\n      try {\n        // All is good. Should we do something more with actual recalled data?\n        await authRecall(gunRoot)\n        return gunRoot._.user._\n      } catch (e) {\n        const err = 'No session!'\n        Gun.log(err)\n        throw { err }\n      }\n    }\n    User.prototype.trust = async function(user){\n      console.log(\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\n      //gun.get('alice').get('age').trust(bob);\n      if (Gun.is(user)) {\n        user.get('pub').get((ctx, ev) => {\n          console.log(ctx, ev)\n        })\n      }\n      user.get('trust').get(path).put(theirPubkey);\n\n      // do a lookup on this gun chain directly (that gets bob's copy of the data)\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\n      // THEN you perform Jachen's mix operation\n      // and return the result of that to...\n    }\n    User.prototype.grant = function(to, cb){\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('grant').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('grant').get(pair.pub).get(path).put(enc);\n      }\n      var pub = to.get('pub').then();\n      var epub = to.get('epub').then();\n      pub = await pub; epub = await epub;\n      var dh = await SEA.secret(epub, pair);\n      enc = await SEA.encrypt(sec, dh);\n      user.get('grant').get(pub).get(path).put(enc, cb);\n      }());\n      return gun;\n    }\n    User.prototype.secret = function(data, cb){\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user.pair(), path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('trust').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('trust').get(pair.pub).get(path).put(enc);\n      }\n      enc = await SEA.encrypt(data, sec);\n      gun.put(enc, cb);\n      }());\n      return gun;\n    }\n\n    /**\n     * returns the decrypted value, encrypted by secret\n     * @returns {Promise<any>}\n     // Mark needs to review 1st before officially supported\n    User.prototype.decrypt = function(cb) {\n      let gun = this,\n        path = ''\n      gun.back(function(at) {\n        if (at.is) {\n          return\n        }\n        path += at.get || ''\n      })\n      return gun\n        .then(async data => {\n          if (data == null) {\n            return\n          }\n          const user = gun.back(-1).user()\n          const pair = user.pair()\n          let sec = await user\n            .get('trust')\n            .get(pair.pub)\n            .get(path)\n          sec = await SEA.decrypt(sec, pair)\n          if (!sec) {\n            return data\n          }\n          let decrypted = await SEA.decrypt(data, sec)\n          return decrypted\n        })\n        .then(res => {\n          cb && cb(res)\n          return res\n        })\n    }\n    */\n    module.exports = User\n  })(USE, './share');\n\n  ;USE(function(module){\n    var SEA = USE('./sea'), S = USE('./settings'), noop = function() {}, u;\n    var Gun = (SEA.window||'').GUN || USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\n    // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\n\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\n    Gun.on('opt', function(at){\n      if(!at.sea){ // only add SEA once per instance, on the \"at\" context.\n        at.sea = {own: {}};\n        at.on('put', check, at); // SEA now runs its firewall on HAM diffs, not all i/o.\n      }\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\n    });\n\n    // Alright, this next adapter gets run at the per node level in the graph database.\n    // correction: 2020 it gets run on each key/value pair in a node upon a HAM diff.\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\n\n    function check(msg){ // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\n      var eve = this, at = eve.as, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\n      if(!soul || !key){ return }\n      if((msg._||'').faith && (at.opt||'').faith && 'function' == typeof msg._){\n        SEA.opt.pack(put, function(raw){\n        SEA.verify(raw, false, function(data){ // this is synchronous if false\n          put['='] = SEA.opt.unpack(data);\n          eve.to.next(msg);\n        })})\n        return \n      }\n      var no = function(why){ at.on('in', {'@': id, err: msg.err = why}) }; // exploit internal relay stun for now, maybe violates spec, but testing for now. // Note: this may be only the sharded message, not original batch.\n      //var no = function(why){ msg.ack(why) };\n      (msg._||'').DBG && ((msg._||'').DBG.c = +new Date);\n      if(0 <= soul.indexOf('<?')){ // special case for \"do not sync data X old\" forget\n        // 'a~pub.key/b<?9'\n        tmp = parseFloat(soul.split('<?')[1]||'');\n        if(tmp && (state < (Gun.state() - (tmp * 1000)))){ // sec to ms\n          (tmp = msg._) && (tmp.stun) && (tmp.stun--); // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\n          return; // omit!\n        }\n      }\n      \n      if('~@' === soul){  // special case for shared system data, the list of aliases.\n        check.alias(eve, msg, val, key, soul, at, no); return;\n      }\n      if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\n        check.pubs(eve, msg, val, key, soul, at, no); return;\n      }\n      //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n      if(tmp = SEA.opt.pub(soul)){ // special case, account data for a public key.\n        check.pub(eve, msg, val, key, soul, at, no, at.user||'', tmp); return;\n      }\n      if(0 <= soul.indexOf('#')){ // special case for content addressing immutable hashed data.\n        check.hash(eve, msg, val, key, soul, at, no); return;\n      } \n      check.any(eve, msg, val, key, soul, at, no, at.user||''); return;\n      eve.to.next(msg); // not handled\n    }\n    check.hash = function(eve, msg, val, key, soul, at, no){ // mark unbuilt @i001962 's epic hex contrib!\n      SEA.work(val, null, function(data){\n        function hexToBase64(hexStr) {\n          let base64 = \"\";\n          for(let i = 0; i < hexStr.length; i++) {\n            base64 += !(i - 1 & 1) ? String.fromCharCode(parseInt(hexStr.substring(i - 1, i + 1), 16)) : \"\"}\n          return btoa(base64);}  \n        if(data && data === key.split('#').slice(-1)[0]){ return eve.to.next(msg) }\n          else if (data && data === hexToBase64(key.split('#').slice(-1)[0])){ \n          return eve.to.next(msg) }\n        no(\"Data hash not same as hash!\");\n      }, {name: 'SHA-256'});\n    }\n    check.alias = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@, ~@alice: {#~@alice}}\n      if(!val){ return no(\"Data must exist!\") } // data MUST exist\n      if('~@'+key === link_is(val)){ return eve.to.next(msg) } // in fact, it must be EXACTLY equal to itself\n      no(\"Alias not same!\"); // if it isn't, reject.\n    };\n    check.pubs = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\n      if(!val){ return no(\"Alias must exist!\") } // data MUST exist\n      if(key === link_is(val)){ return eve.to.next(msg) } // and the ID must be EXACTLY equal to its property\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\n    };\n    check.pub = async function(eve, msg, val, key, soul, at, no, user, pub){ var tmp // Example: {_:#~asdf, hello:'world'~fdsa}}\n      const raw = await S.parse(val) || {}\n      const verify = (certificate, certificant, cb) => {\n        if (certificate.m && certificate.s && certificant && pub)\n          // now verify certificate\n          return SEA.verify(certificate, pub, data => { // check if \"pub\" (of the graph owner) really issued this cert\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\") // certificate expired\n            // \"data.c\" = a list of certificants/certified users\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : ''\n              String.match = String.match || Gun.text.match\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : []\n              for (const lex of w) {\n                if ((String.match(path, lex['#']) && String.match(key, lex['.'])) || (!lex['.'] && String.match(path, lex['#'])) || (!lex['#'] && String.match(key, lex['.'])) || String.match((path ? path + '/' + key : key), lex['#'] || lex)) {\n                  // is Certificant forced to present in Path\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`)\n                  // path is allowed, but is there any WRITE block? Check it out\n                  if (data.wb && (typeof data.wb === 'string' || ((data.wb || {})['#']))) { // \"data.wb\" = path to the WRITE block\n                    var root = eve.as.root.$.back(-1)\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub)\n                    return root.get(data.wb).get(certificant).once(value => { // TODO: INTENT TO DEPRECATE.\n                      if (value && (value === 1 || value === true)) return no(`Certificant ${certificant} blocked.`)\n                      return cb(data)\n                    })\n                  }\n                  return cb(data)\n                }\n              }\n              return no(\"Certificate verification fail.\")\n            }\n          })\n        return\n      }\n      \n      if ('pub' === key && '~' + pub === soul) {\n        if (val === pub) return eve.to.next(msg) // the account MUST match `pub` property that equals the ID of the public key.\n        return no(\"Account not same!\")\n      }\n\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || (pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert))){\n        SEA.opt.pack(msg.put, packed => {\n          SEA.sign(packed, (user._).sea, async function(data) {\n            if (u === data) return no(SEA.err || 'Signature fail.')\n            msg.put[':'] = {':': tmp = SEA.opt.unpack(data.m), '~': data.s}\n            msg.put['='] = tmp\n  \n            // if writing to own graph, just allow it\n            if (pub === user.is.pub) {\n              if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n              JSON.stringifyAsync(msg.put[':'], function(err,s){\n                if(err){ return no(err || \"Stringify error.\") }\n                msg.put[':'] = s;\n                return eve.to.next(msg);\n              })\n              return\n            }\n  \n            // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\n            if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {\n              const cert = await S.parse(msg._.msg.opt.cert)\n              // even if cert exists, we must verify it\n              if (cert && cert.m && cert.s)\n                verify(cert, user.is.pub, _ => {\n                  msg.put[':']['+'] = cert // '+' is a certificate\n                  msg.put[':']['*'] = user.is.pub // '*' is pub of the user who puts\n                  JSON.stringifyAsync(msg.put[':'], function(err,s){\n                    if(err){ return no(err || \"Stringify error.\") }\n                    msg.put[':'] = s;\n                    return eve.to.next(msg);\n                  })\n                  return\n                })\n            }\n          }, {raw: 1})\n        })\n        return;\n      }\n\n      SEA.opt.pack(msg.put, packed => {\n        SEA.verify(packed, raw['*'] || pub, function(data){ var tmp;\n          data = SEA.opt.unpack(data);\n          if (u === data) return no(\"Unverified data.\") // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\n          if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n          \n          // check if cert ('+') and putter's pub ('*') exist\n          if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*'])\n            // now verify certificate\n            verify(raw['+'], raw['*'], _ => {\n              msg.put['='] = data;\n              return eve.to.next(msg);\n            })\n          else {\n            msg.put['='] = data;\n            return eve.to.next(msg);\n          }\n        });\n      })\n      return\n    };\n    check.any = function(eve, msg, val, key, soul, at, no, user){ var tmp, pub;\n      if(at.opt.secure){ return no(\"Soul missing public key at '\" + key + \"'.\") }\n      // TODO: Ask community if should auto-sign non user-graph data.\n      at.on('secure', function(msg){ this.off();\n        if(!at.opt.secure){ return eve.to.next(msg) }\n        no(\"Data cannot be changed.\");\n      }).on.on('secure', msg);\n      return;\n    }\n\n    var valid = Gun.valid, link_is = function(d,l){ return 'string' == typeof (l = valid(d)) && l }, state_ify = (Gun.state||'').ify;\n\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\n    SEA.opt.pub = function(s){\n      if(!s){ return }\n      s = s.split('~');\n      if(!s || !(s = s[1])){ return }\n      s = s.split(pubcut).slice(0,2);\n      if(!s || 2 != s.length){ return }\n      if('@' === (s[0]||'')[0]){ return }\n      s = s.slice(0,2).join('.');\n      return s;\n    }\n    SEA.opt.stringy = function(t){\n      // TODO: encrypt etc. need to check string primitive. Make as breaking change.\n    }\n    SEA.opt.pack = function(d,cb,k, n,s){ var tmp, f; // pack for verifying\n      if(SEA.opt.check(d)){ return cb(d) }\n      if(d && d['#'] && d['.'] && d['>']){ tmp = d[':']; f = 1 }\n      JSON.parseAsync(f? tmp : d, function(err, meta){\n        var sig = ((u !== (meta||'')[':']) && (meta||'')['~']); // or just ~ check?\n        if(!sig){ cb(d); return }\n        cb({m: {'#':s||d['#'],'.':k||d['.'],':':(meta||'')[':'],'>':d['>']||Gun.state.is(n, k)}, s: sig});\n      });\n    }\n    var O = SEA.opt;\n    SEA.opt.unpack = function(d, k, n){ var tmp;\n      if(u === d){ return }\n      if(d && (u !== (tmp = d[':']))){ return tmp }\n      k = k || O.fall_key; if(!n && O.fall_val){ n = {}; n[k] = O.fall_val }\n      if(!k || !n){ return }\n      if(d === n[k]){ return d }\n      if(!SEA.opt.check(n[k])){ return d }\n      var soul = (n && n._ && n._['#']) || O.fall_soul, s = Gun.state.is(n, k) || O.fall_state;\n      if(d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])){\n        return d[2];\n      }\n      if(s < SEA.opt.shuffle_attack){\n        return d;\n      }\n    }\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\n\n  })(USE, './index');\n}());\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$buffer$index"]],"~:properties",["^5",["crv","window","encrypt","fall_verify","btoa","random","ossl","pubs","protocol","list","TextDecoder","lol","keyid","opt","prototype","plugin","recall","pack","delete","err","hash","why","user","auth","directory","grant","GUN","fall_val","User","epub","validity","sea","tagLength","toString","shuffle","stringy","subtle","shuffle_attack","iterations","Buffer","remember","any","name","kty","ext","uuid","priv","verify","check","fall_soul","epriv","parseAsync","half","trust","what","wait","proof","ing","alg","leave","crypto","own","enc","namedCurve","length","pair","salt","SEA","fallback","pub","slow_leak","key_ops","stringify","secret","match","work","how","from","decrypt","create","parse","public","TextEncoder","DANGER","alias","then","fall_key","alive","iter","raw","jwk","unpack","pbkdf2","ecdsa","data","get","encode","sign","hook","certify","stringifyAsync","chain","ecdh","atob","change","keyToJwk","constructor","fall_state"]],"~:compiled-at",1676648415807,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$gun$sea.js\",\n\"lineCount\":70,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/gun/sea.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$gun$sea\\\"] = function(global,require,module,exports) {\\nvar Buffer = require('buffer').Buffer;\\n;(function(){\\n\\n  /* UNBUILD */\\n  function USE(arg, req){\\n    return req? require(arg) : arg.slice? USE[R(arg)] : function(mod, path){\\n      arg(mod = {exports: {}});\\n      USE[R(path)] = mod.exports;\\n    }\\n    function R(p){\\n      return p.split('/').slice(-1).toString().replace('.js','');\\n    }\\n  }\\n  if(typeof module !== \\\"undefined\\\"){ var MODULE = module }\\n  /* UNBUILD */\\n\\n  ;USE(function(module){\\n    // Security, Encryption, and Authorization: SEA.js\\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\\n    // THIS IS AN EARLY ALPHA!\\n\\n    if(typeof self !== \\\"undefined\\\"){ module.window = self } // should be safe for at least browser/worker/nodejs, need to check other envs like RN etc.\\n    if(typeof window !== \\\"undefined\\\"){ module.window = window }\\n\\n    var tmp = module.window || module, u;\\n    var SEA = tmp.SEA || {};\\n\\n    if(SEA.window = module.window){ SEA.window.SEA = SEA }\\n\\n    try{ if(u+'' !== typeof MODULE){ MODULE.exports = SEA } }catch(e){}\\n    module.exports = SEA;\\n  })(USE, './root');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    try{ if(SEA.window){\\n      if(location.protocol.indexOf('s') < 0\\n      && location.host.indexOf('localhost') < 0\\n      && ! /^127\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+$/.test(location.hostname)\\n      && location.protocol.indexOf('file:') < 0){\\n        console.warn('HTTPS needed for WebCrypto in SEA, redirecting...');\\n        location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\\n      }\\n    } }catch(e){}\\n  })(USE, './https');\\n\\n  ;USE(function(module){\\n    var u;\\n    if(u+''== typeof btoa){\\n      if(u+'' == typeof Buffer){\\n        try{ global.Buffer = USE(\\\"buffer\\\", 1).Buffer }catch(e){ console.log(\\\"Please `npm install buffer` or add it to your package.json !\\\") }\\n      }\\n      global.btoa = function(data){ return Buffer.from(data, \\\"binary\\\").toString(\\\"base64\\\") };\\n      global.atob = function(data){ return Buffer.from(data, \\\"base64\\\").toString(\\\"binary\\\") };\\n    }\\n  })(USE, './base64');\\n\\n  ;USE(function(module){\\n    USE('./base64');\\n    // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\\n    function SeaArray() {}\\n    Object.assign(SeaArray, { from: Array.from })\\n    SeaArray.prototype = Object.create(Array.prototype)\\n    SeaArray.prototype.toString = function(enc, start, end) { enc = enc || 'utf8'; start = start || 0;\\n      const length = this.length\\n      if (enc === 'hex') {\\n        const buf = new Uint8Array(this)\\n        return [ ...Array(((end && (end + 1)) || length) - start).keys()]\\n        .map((i) => buf[ i + start ].toString(16).padStart(2, '0')).join('')\\n      }\\n      if (enc === 'utf8') {\\n        return Array.from(\\n          { length: (end || length) - start },\\n          (_, i) => String.fromCharCode(this[ i + start])\\n        ).join('')\\n      }\\n      if (enc === 'base64') {\\n        return btoa(this)\\n      }\\n    }\\n    module.exports = SeaArray;\\n  })(USE, './array');\\n\\n  ;USE(function(module){\\n    USE('./base64');\\n    // This is Buffer implementation used in SEA. Functionality is mostly\\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\\n    // between binary and 'hex' | 'utf8' | 'base64'\\n    // See documentation and validation for safe implementation in:\\n    // https://github.com/feross/safe-buffer#update\\n    var SeaArray = USE('./array');\\n    function SafeBuffer(...props) {\\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()')\\n      return SafeBuffer.from(...props)\\n    }\\n    SafeBuffer.prototype = Object.create(Array.prototype)\\n    Object.assign(SafeBuffer, {\\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\\n      from() {\\n        if (!Object.keys(arguments).length || arguments[0]==null) {\\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\\n        }\\n        const input = arguments[0]\\n        let buf\\n        if (typeof input === 'string') {\\n          const enc = arguments[1] || 'utf8'\\n          if (enc === 'hex') {\\n            const bytes = input.match(/([\\\\da-fA-F]{2})/g)\\n            .map((byte) => parseInt(byte, 16))\\n            if (!bytes || !bytes.length) {\\n              throw new TypeError('Invalid first argument for type \\\\'hex\\\\'.')\\n            }\\n            buf = SeaArray.from(bytes)\\n          } else if (enc === 'utf8' || 'binary' === enc) { // EDIT BY MARK: I think this is safe, tested it against a couple \\\"binary\\\" strings. This lets SafeBuffer match NodeJS Buffer behavior more where it safely btoas regular strings.\\n            const length = input.length\\n            const words = new Uint16Array(length)\\n            Array.from({ length: length }, (_, i) => words[i] = input.charCodeAt(i))\\n            buf = SeaArray.from(words)\\n          } else if (enc === 'base64') {\\n            const dec = atob(input)\\n            const length = dec.length\\n            const bytes = new Uint8Array(length)\\n            Array.from({ length: length }, (_, i) => bytes[i] = dec.charCodeAt(i))\\n            buf = SeaArray.from(bytes)\\n          } else if (enc === 'binary') { // deprecated by above comment\\n            buf = SeaArray.from(input) // some btoas were mishandled.\\n          } else {\\n            console.info('SafeBuffer.from unknown encoding: '+enc)\\n          }\\n          return buf\\n        }\\n        const byteLength = input.byteLength // what is going on here? FOR MARTTI\\n        const length = input.byteLength ? input.byteLength : input.length\\n        if (length) {\\n          let buf\\n          if (input instanceof ArrayBuffer) {\\n            buf = new Uint8Array(input)\\n          }\\n          return SeaArray.from(buf || input)\\n        }\\n      },\\n      // This is 'safe-buffer.alloc' sans encoding support\\n      alloc(length, fill = 0 /*, enc*/ ) {\\n        return SeaArray.from(new Uint8Array(Array.from({ length: length }, () => fill)))\\n      },\\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\\n      allocUnsafe(length) {\\n        return SeaArray.from(new Uint8Array(Array.from({ length : length })))\\n      },\\n      // This puts together array of array like members\\n      concat(arr) { // octet array\\n        if (!Array.isArray(arr)) {\\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.')\\n        }\\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []))\\n      }\\n    })\\n    SafeBuffer.prototype.from = SafeBuffer.from\\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString\\n\\n    module.exports = SafeBuffer;\\n  })(USE, './buffer');\\n\\n  ;USE(function(module){\\n    const SEA = USE('./root')\\n    const api = {Buffer: USE('./buffer')}\\n    var o = {}, u;\\n\\n    // ideally we can move away from JSON entirely? unlikely due to compatibility issues... oh well.\\n    JSON.parseAsync = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\\n    JSON.stringifyAsync = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\\n\\n    api.parse = function(t,r){ return new Promise(function(res, rej){\\n      JSON.parseAsync(t,function(err, raw){ err? rej(err) : res(raw) },r);\\n    })}\\n    api.stringify = function(v,r,s){ return new Promise(function(res, rej){\\n      JSON.stringifyAsync(v,function(err, raw){ err? rej(err) : res(raw) },r,s);\\n    })}\\n\\n    if(SEA.window){\\n      api.crypto = SEA.window.crypto || SEA.window.msCrypto\\n      api.subtle = (api.crypto||o).subtle || (api.crypto||o).webkitSubtle;\\n      api.TextEncoder = SEA.window.TextEncoder;\\n      api.TextDecoder = SEA.window.TextDecoder;\\n      api.random = (len) => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len))));\\n    }\\n    if(!api.TextDecoder)\\n    {\\n      const { TextEncoder, TextDecoder } = USE((u+'' == typeof MODULE?'.':'')+'./lib/text-encoding', 1);\\n      api.TextDecoder = TextDecoder;\\n      api.TextEncoder = TextEncoder;\\n    }\\n    if(!api.crypto)\\n    {\\n      try\\n      {\\n      var crypto = USE('crypto', 1);\\n      Object.assign(api, {\\n        crypto,\\n        random: (len) => api.Buffer.from(crypto.randomBytes(len))\\n      });      \\n      const { Crypto: WebCrypto } = USE('@peculiar/webcrypto', 1);\\n      api.ossl = api.subtle = new WebCrypto({directory: 'ossl'}).subtle // ECDH\\n    }\\n    catch(e){\\n      console.log(\\\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\\\");\\n    }}\\n\\n    module.exports = api\\n  })(USE, './shim');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var s = {};\\n    s.pbkdf2 = {hash: {name : 'SHA-256'}, iter: 100000, ks: 64};\\n    s.ecdsa = {\\n      pair: {name: 'ECDSA', namedCurve: 'P-256'},\\n      sign: {name: 'ECDSA', hash: {name: 'SHA-256'}}\\n    };\\n    s.ecdh = {name: 'ECDH', namedCurve: 'P-256'};\\n\\n    // This creates Web Cryptography API compliant JWK for sign/verify purposes\\n    s.jwk = function(pub, d){  // d === priv\\n      pub = pub.split('.');\\n      var x = pub[0], y = pub[1];\\n      var jwk = {kty: \\\"EC\\\", crv: \\\"P-256\\\", x: x, y: y, ext: true};\\n      jwk.key_ops = d ? ['sign'] : ['verify'];\\n      if(d){ jwk.d = d }\\n      return jwk;\\n    };\\n    \\n    s.keyToJwk = function(keyBytes) {\\n      const keyB64 = keyBytes.toString('base64');\\n      const k = keyB64.replace(/\\\\+/g, '-').replace(/\\\\//g, '_').replace(/\\\\=/g, '');\\n      return { kty: 'oct', k: k, ext: false, alg: 'A256GCM' };\\n    }\\n\\n    s.recall = {\\n      validity: 12 * 60 * 60, // internally in seconds : 12 hours\\n      hook: function(props){ return props } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\\n    };\\n\\n    s.check = function(t){ return (typeof t == 'string') && ('SEA{' === t.slice(0,4)) }\\n    s.parse = async function p(t){ try {\\n      var yes = (typeof t == 'string');\\n      if(yes && 'SEA{' === t.slice(0,4)){ t = t.slice(3) }\\n      return yes ? await shim.parse(t) : t;\\n      } catch (e) {}\\n      return t;\\n    }\\n\\n    SEA.opt = s;\\n    module.exports = s\\n  })(USE, './settings');\\n\\n  ;USE(function(module){\\n    var shim = USE('./shim');\\n    module.exports = async function(d, o){\\n      var t = (typeof d == 'string')? d : await shim.stringify(d);\\n      var hash = await shim.subtle.digest({name: o||'SHA-256'}, new shim.TextEncoder().encode(t));\\n      return shim.Buffer.from(hash);\\n    }\\n  })(USE, './sha256');\\n\\n  ;USE(function(module){\\n    // This internal func returns SHA-1 hashed data for KeyID generation\\n    const __shim = USE('./shim')\\n    const subtle = __shim.subtle\\n    const ossl = __shim.ossl ? __shim.ossl : subtle\\n    const sha1hash = (b) => ossl.digest({name: 'SHA-1'}, new ArrayBuffer(b))\\n    module.exports = sha1hash\\n  })(USE, './sha1');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var sha = USE('./sha256');\\n    var u;\\n\\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => { try { // used to be named `proof`\\n      var salt = (pair||{}).epub || pair; // epub not recommended, salt should be random!\\n      opt = opt || {};\\n      if(salt instanceof Function){\\n        cb = salt;\\n        salt = u;\\n      }\\n      data = (typeof data == 'string')? data : await shim.stringify(data);\\n      if('sha' === (opt.name||'').toLowerCase().slice(0,3)){\\n        var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64')\\n        if(cb){ try{ cb(rsha) }catch(e){console.log(e)} }\\n        return rsha;\\n      }\\n      salt = salt || shim.random(9);\\n      var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {name: opt.name || 'PBKDF2'}, false, ['deriveBits']);\\n      var work = await (shim.ossl || shim.subtle).deriveBits({\\n        name: opt.name || 'PBKDF2',\\n        iterations: opt.iterations || S.pbkdf2.iter,\\n        salt: new shim.TextEncoder().encode(opt.salt || salt),\\n        hash: opt.hash || S.pbkdf2.hash,\\n      }, key, opt.length || (S.pbkdf2.ks * 8))\\n      data = shim.random(data.length)  // Erase data in case of passphrase\\n      var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64')\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) { \\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.work;\\n  })(USE, './work');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n\\n    SEA.name = SEA.name || (async (cb, opt) => { try {\\n      if(cb){ try{ cb() }catch(e){console.log(e)} }\\n      return;\\n    } catch(e) {\\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    //SEA.pair = async (data, proof, cb) => { try {\\n    SEA.pair = SEA.pair || (async (cb, opt) => { try {\\n\\n      var ecdhSubtle = shim.ossl || shim.subtle;\\n      // First: ECDSA keys for signing/verifying...\\n      var sa = await shim.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, [ 'sign', 'verify' ])\\n      .then(async (keys) => {\\n        // privateKey scope doesn't leak out from here!\\n        //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\\n        var key = {};\\n        key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\\n        var pub = await shim.subtle.exportKey('jwk', keys.publicKey);\\n        //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\\n        key.pub = pub.x+'.'+pub.y; // new\\n        // x and y are already base64\\n        // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\\n        // but split on a non-base64 letter.\\n        return key;\\n      })\\n      \\n      // To include PGPv4 kind of keyId:\\n      // const pubId = await SEA.keyid(keys.pub)\\n      // Next: ECDH keys for encryption/decryption...\\n\\n      try{\\n      var dh = await ecdhSubtle.generateKey({name: 'ECDH', namedCurve: 'P-256'}, true, ['deriveKey'])\\n      .then(async (keys) => {\\n        // privateKey scope doesn't leak out from here!\\n        var key = {};\\n        key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\\n        var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey);\\n        //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\\n        key.epub = pub.x+'.'+pub.y; // new\\n        // ex and ey are already base64\\n        // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\\n        // but split on a non-base64 letter.\\n        return key;\\n      })\\n      }catch(e){\\n        if(SEA.window){ throw e }\\n        if(e == 'Error: ECDH is not a supported algorithm'){ console.log('Ignoring ECDH...') }\\n        else { throw e }\\n      } dh = dh || {};\\n\\n      var r = { pub: sa.pub, priv: sa.priv, /* pubId, */ epub: dh.epub, epriv: dh.epriv }\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) {\\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.pair;\\n  })(USE, './pair');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var sha = USE('./sha256');\\n    var u;\\n\\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => { try {\\n      opt = opt || {};\\n      if(!(pair||opt).priv){\\n        if(!SEA.I){ throw 'No signing key.' }\\n        pair = await SEA.I(null, {what: data, how: 'sign', why: opt.why});\\n      }\\n      if(u === data){ throw '`undefined` not allowed.' }\\n      var json = await S.parse(data);\\n      var check = opt.check = opt.check || json;\\n      if(SEA.verify && (SEA.opt.check(check) || (check && check.s && check.m))\\n      && u !== await SEA.verify(check, pair)){ // don't sign if we already signed it.\\n        var r = await S.parse(check);\\n        if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\\n        if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n        return r;\\n      }\\n      var pub = pair.pub;\\n      var priv = pair.priv;\\n      var jwk = S.jwk(pub, priv);\\n      var hash = await sha(json);\\n      var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, ['sign'])\\n      .then((key) => (shim.ossl || shim.subtle).sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, new Uint8Array(hash))) // privateKey scope doesn't leak out from here!\\n      var r = {m: json, s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')}\\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\\n\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) {\\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.sign;\\n  })(USE, './sign');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var sha = USE('./sha256');\\n    var u;\\n\\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => { try {\\n      var json = await S.parse(data);\\n      if(false === pair){ // don't verify!\\n        var raw = await S.parse(json.m);\\n        if(cb){ try{ cb(raw) }catch(e){console.log(e)} }\\n        return raw;\\n      }\\n      opt = opt || {};\\n      // SEA.I // verify is free! Requires no user permission.\\n      var pub = pair.pub || pair;\\n      var key = SEA.opt.slow_leak? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {name: 'ECDSA', namedCurve: 'P-256'}, false, ['verify']);\\n      var hash = await sha(json.m);\\n      var buf, sig, check, tmp; try{\\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\\n        sig = new Uint8Array(buf);\\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash));\\n        if(!check){ throw \\\"Signature did not match.\\\" }\\n      }catch(e){\\n        if(SEA.opt.fallback){\\n          return await SEA.opt.fall_verify(data, pair, cb, opt);\\n        }\\n      }\\n      var r = check? await S.parse(json.m) : u;\\n\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) {\\n      console.log(e); // mismatched owner FOR MARTTI\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.verify;\\n    // legacy & ossl memory leak mitigation:\\n\\n    var knownKeys = {};\\n    var keyForPair = SEA.opt.slow_leak = pair => {\\n      if (knownKeys[pair]) return knownKeys[pair];\\n      var jwk = S.jwk(pair);\\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\\\"jwk\\\", jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, [\\\"verify\\\"]);\\n      return knownKeys[pair];\\n    };\\n\\n    var O = SEA.opt;\\n    SEA.opt.fall_verify = async function(data, pair, cb, opt, f){\\n      if(f === SEA.opt.fallback){ throw \\\"Signature did not match\\\" } f = f || 1;\\n      var tmp = data||'';\\n      data = SEA.opt.unpack(data) || data;\\n      var json = await S.parse(data), pub = pair.pub || pair, key = await SEA.opt.slow_leak(pub);\\n      var hash = (f <= SEA.opt.fallback)? shim.Buffer.from(await shim.subtle.digest({name: 'SHA-256'}, new shim.TextEncoder().encode(await S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\\n      var buf; var sig; var check; try{\\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64') // NEW DEFAULT!\\n        sig = new Uint8Array(buf)\\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\\n        if(!check){ throw \\\"Signature did not match.\\\" }\\n      }catch(e){ try{\\n        buf = shim.Buffer.from(json.s, 'utf8') // AUTO BACKWARD OLD UTF8 DATA!\\n        sig = new Uint8Array(buf)\\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\\n        }catch(e){\\n        if(!check){ throw \\\"Signature did not match.\\\" }\\n        }\\n      }\\n      var r = check? await S.parse(json.m) : u;\\n      O.fall_soul = tmp['#']; O.fall_key = tmp['.']; O.fall_val = data; O.fall_state = tmp['>'];\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    }\\n    SEA.opt.fallback = 2;\\n\\n  })(USE, './verify');\\n\\n  ;USE(function(module){\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var sha256hash = USE('./sha256');\\n\\n    const importGen = async (key, salt, opt) => {\\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\\n      opt = opt || {};\\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary')\\n      \\n      const jwkKey = S.keyToJwk(hash)      \\n      return await shim.subtle.importKey('jwk', jwkKey, {name:'AES-GCM'}, false, ['encrypt', 'decrypt'])\\n    }\\n    module.exports = importGen;\\n  })(USE, './aeskey');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var aeskey = USE('./aeskey');\\n    var u;\\n\\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => { try {\\n      opt = opt || {};\\n      var key = (pair||opt).epriv || pair;\\n      if(u === data){ throw '`undefined` not allowed.' }\\n      if(!key){\\n        if(!SEA.I){ throw 'No encryption key.' }\\n        pair = await SEA.I(null, {what: data, how: 'encrypt', why: opt.why});\\n        key = pair.epriv || pair;\\n      }\\n      var msg = (typeof data == 'string')? data : await shim.stringify(data);\\n      var rand = {s: shim.random(9), iv: shim.random(15)}; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\\n      var ct = await aeskey(key, rand.s, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).encrypt({ // Keeping the AES key scope as private as possible...\\n        name: opt.name || 'AES-GCM', iv: new Uint8Array(rand.iv)\\n      }, aes, new shim.TextEncoder().encode(msg)));\\n      var r = {\\n        ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\\n        iv: rand.iv.toString(opt.encode || 'base64'),\\n        s: rand.s.toString(opt.encode || 'base64')\\n      }\\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\\n\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) { \\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.encrypt;\\n  })(USE, './encrypt');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    var aeskey = USE('./aeskey');\\n\\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => { try {\\n      opt = opt || {};\\n      var key = (pair||opt).epriv || pair;\\n      if(!key){\\n        if(!SEA.I){ throw 'No decryption key.' }\\n        pair = await SEA.I(null, {what: data, how: 'decrypt', why: opt.why});\\n        key = pair.epriv || pair;\\n      }\\n      var json = await S.parse(data);\\n      var buf, bufiv, bufct; try{\\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64');\\n        bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\\n        bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\\n        var ct = await aeskey(key, buf, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).decrypt({  // Keeping aesKey scope as private as possible...\\n          name: opt.name || 'AES-GCM', iv: new Uint8Array(bufiv), tagLength: 128\\n        }, aes, new Uint8Array(bufct)));\\n      }catch(e){\\n        if('utf8' === opt.encode){ throw \\\"Could not decrypt\\\" }\\n        if(SEA.opt.fallback){\\n          opt.encode = 'utf8';\\n          return await SEA.decrypt(data, pair, cb, opt);\\n        }\\n      }\\n      var r = await S.parse(new shim.TextDecoder('utf8').decode(ct));\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) { \\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.decrypt;\\n  })(USE, './decrypt');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    var shim = USE('./shim');\\n    var S = USE('./settings');\\n    // Derive shared secret from other's pub and my epub/epriv \\n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => { try {\\n      opt = opt || {};\\n      if(!pair || !pair.epriv || !pair.epub){\\n        if(!SEA.I){ throw 'No secret mix.' }\\n        pair = await SEA.I(null, {what: key, how: 'secret', why: opt.why});\\n      }\\n      var pub = key.epub || key;\\n      var epub = pair.epub;\\n      var epriv = pair.epriv;\\n      var ecdhSubtle = shim.ossl || shim.subtle;\\n      var pubKeyData = keysToEcdhJwk(pub);\\n      var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) },{name: 'ECDH', namedCurve: 'P-256'}); // Thanks to @sirpy !\\n      var privKeyData = keysToEcdhJwk(epub, epriv);\\n      var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async (privKey) => {\\n        // privateKey scope doesn't leak out from here!\\n        var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\\n        var rawBits = new Uint8Array(derivedBits);\\n        var derivedKey = await ecdhSubtle.importKey('raw', rawBits,{ name: 'AES-GCM', length: 256 }, true, [ 'encrypt', 'decrypt' ]);\\n        return ecdhSubtle.exportKey('jwk', derivedKey).then(({ k }) => k);\\n      })\\n      var r = derived;\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) {\\n      console.log(e);\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    // can this be replaced with settings.jwk?\\n    var keysToEcdhJwk = (pub, d) => { // d === priv\\n      //var [ x, y ] = shim.Buffer.from(pub, 'base64').toString('utf8').split(':') // old\\n      var [ x, y ] = pub.split('.') // new\\n      var jwk = d ? { d: d } : {}\\n      return [  // Use with spread returned value...\\n        'jwk',\\n        Object.assign(\\n          jwk,\\n          { x: x, y: y, kty: 'EC', crv: 'P-256', ext: true }\\n        ), // ??? refactor\\n        {name: 'ECDH', namedCurve: 'P-256'}\\n      ]\\n    }\\n\\n    module.exports = SEA.secret;\\n  })(USE, './secret');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./root');\\n    // This is to certify that a group of \\\"certificants\\\" can \\\"put\\\" anything at a group of matched \\\"paths\\\" to the certificate authority's graph\\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => { try {\\n      /*\\n      The Certify Protocol was made out of love by a Vietnamese code enthusiast. Vietnamese people around the world deserve respect!\\n      IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\\n      \\\"certificants\\\": '*' or a String (Bob.pub) || an Object that contains \\\"pub\\\" as a key || an array of [object || string]. These people will have the rights.\\n      \\\"policy\\\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \\\"?\\\" with indexOf(\\\"*\\\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\\n      \\\"authority\\\": Key pair or priv of the certificate authority.\\n      \\\"cb\\\": A callback function after all things are done.\\n      \\\"opt\\\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.block is set, SEA will look for block before syncing.\\n      */\\n      console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.')\\n\\n      certificants = (() => {\\n        var data = []\\n        if (certificants) {\\n          if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') > -1) return '*'\\n          if (typeof certificants === 'string') return certificants\\n          if (Array.isArray(certificants)) {\\n            if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null\\n            certificants.map(certificant => {\\n              if (typeof certificant ==='string') data.push(certificant)\\n              else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub)\\n            })\\n          }\\n\\n          if (typeof certificants === 'object' && certificants.pub) return certificants.pub\\n          return data.length > 0 ? data : null\\n        }\\n        return\\n      })()\\n\\n      if (!certificants) return console.log(\\\"No certificant found.\\\")\\n\\n      const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null\\n      const readPolicy = (policy || {}).read ? policy.read : null\\n      const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\\\"+\\\"] || policy[\\\"#\\\"] || policy[\\\".\\\"] || policy[\\\"=\\\"] || policy[\\\"*\\\"] || policy[\\\">\\\"] || policy[\\\"<\\\"] ? policy : null\\n      // The \\\"blacklist\\\" feature is now renamed to \\\"block\\\". Why ? BECAUSE BLACK LIVES MATTER!\\n      // We can now use 3 keys: block, blacklist, ban\\n      const block = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {}\\n      const readBlock = block.read && (typeof block.read === 'string' || (block.read || {})['#']) ? block.read : null\\n      const writeBlock = typeof block === 'string' ? block : block.write && (typeof block.write === 'string' || block.write['#']) ? block.write : null\\n\\n      if (!readPolicy && !writePolicy) return console.log(\\\"No policy found.\\\")\\n\\n      // reserved keys: c, e, r, w, rb, wb\\n      const data = JSON.stringify({\\n        c: certificants,\\n        ...(expiry ? {e: expiry} : {}), // inject expiry if possible\\n        ...(readPolicy ? {r: readPolicy }  : {}), // \\\"r\\\" stands for read, which means read permission.\\n        ...(writePolicy ? {w: writePolicy} : {}), // \\\"w\\\" stands for write, which means write permission.\\n        ...(readBlock ? {rb: readBlock} : {}), // inject READ block if possible\\n        ...(writeBlock ? {wb: writeBlock} : {}), // inject WRITE block if possible\\n      })\\n\\n      const certificate = await SEA.sign(data, authority, null, {raw:1})\\n\\n      var r = certificate\\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\\n      return r;\\n    } catch(e) {\\n      SEA.err = e;\\n      if(SEA.throw){ throw e }\\n      if(cb){ cb() }\\n      return;\\n    }});\\n\\n    module.exports = SEA.certify;\\n  })(USE, './certify');\\n\\n  ;USE(function(module){\\n    var shim = USE('./shim');\\n    // Practical examples about usage found in tests.\\n    var SEA = USE('./root');\\n    SEA.work = USE('./work');\\n    SEA.sign = USE('./sign');\\n    SEA.verify = USE('./verify');\\n    SEA.encrypt = USE('./encrypt');\\n    SEA.decrypt = USE('./decrypt');\\n    SEA.certify = USE('./certify');\\n    //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\\n\\n    SEA.random = SEA.random || shim.random;\\n\\n    // This is Buffer used in SEA and usable from Gun/SEA application also.\\n    // For documentation see https://nodejs.org/api/buffer.html\\n    SEA.Buffer = SEA.Buffer || USE('./buffer');\\n\\n    // These SEA functions support now ony Promises or\\n    // async/await (compatible) code, use those like Promises.\\n    //\\n    // Creates a wrapper library around Web Crypto API\\n    // for various AES, ECDSA, PBKDF2 functions we called above.\\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\\n    SEA.keyid = SEA.keyid || (async (pub) => {\\n      try {\\n        // base64('base64(x):base64(y)') => shim.Buffer(xy)\\n        const pb = shim.Buffer.concat(\\n          pub.replace(/-/g, '+').replace(/_/g, '/').split('.')\\n          .map((t) => shim.Buffer.from(t, 'base64'))\\n        )\\n        // id is PGPv4 compliant raw key\\n        const id = shim.Buffer.concat([\\n          shim.Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb\\n        ])\\n        const sha1 = await sha1hash(id)\\n        const hash = shim.Buffer.from(sha1, 'binary')\\n        return hash.toString('hex', hash.length - 8)  // 16-bit ID as hex\\n      } catch (e) {\\n        console.log(e)\\n        throw e\\n      }\\n    });\\n    // all done!\\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\\n    // SEA should be a full suite that is easy and seamless to use.\\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\\n    // But all other behavior needs to be equally easy, like opinionated ways of\\n    // Adding friends (trusted public keys), sending private messages, etc.\\n    // Cheers! Tell me what you think.\\n    ((SEA.window||{}).GUN||{}).SEA = SEA;\\n\\n    module.exports = SEA\\n    // -------------- END SEA MODULES --------------------\\n    // -- BEGIN SEA+GUN MODULES: BUNDLED BY DEFAULT UNTIL OTHERS USE SEA ON OWN -------\\n  })(USE, './sea');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./sea'), Gun, u;\\n    if(SEA.window){\\n      Gun = SEA.window.GUN || {chain:{}};\\n    } else {\\n      Gun = USE((u+'' == typeof MODULE?'.':'')+'./gun', 1);\\n    }\\n    SEA.GUN = Gun;\\n\\n    function User(root){ \\n      this._ = {$: this};\\n    }\\n    User.prototype = (function(){ function F(){}; F.prototype = Gun.chain; return new F() }()) // Object.create polyfill\\n    User.prototype.constructor = User;\\n\\n    // let's extend the gun chain with a `user` function.\\n    // only one user can be logged in at a time, per gun instance.\\n    Gun.chain.user = function(pub){\\n      var gun = this, root = gun.back(-1), user;\\n      if(pub){\\n        pub = SEA.opt.pub((pub._||'')['#']) || pub;\\n        return root.get('~'+pub);\\n      }\\n      if(user = root.back('user')){ return user }\\n      var root = (root._), at = root, uuid = at.opt.uuid || lex;\\n      (at = (user = at.user = gun.chain(new User))._).opt = {};\\n      at.opt.uuid = function(cb){\\n        var id = uuid(), pub = root.user;\\n        if(!pub || !(pub = pub.is) || !(pub = pub.pub)){ return id }\\n        id = '~' + pub + '/' + id;\\n        if(cb && cb.call){ cb(null, id) }\\n        return id;\\n      }\\n      return user;\\n    }\\n    function lex(){ return Gun.state().toString(36).replace('.','') }\\n    Gun.User = User;\\n    User.GUN = Gun;\\n    User.SEA = Gun.SEA = SEA;\\n    module.exports = User;\\n  })(USE, './user');\\n\\n  ;USE(function(module){\\n    var u, Gun = (''+u != typeof GUN)? (GUN||{chain:{}}) : USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\\n    Gun.chain.then = function(cb, opt){\\n      var gun = this, p = (new Promise(function(res, rej){\\n        gun.once(res, opt);\\n      }));\\n      return cb? p.then(cb) : p;\\n    }\\n  })(USE, './then');\\n\\n  ;USE(function(module){\\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\\n\\n    // Well first we have to actually create a user. That is what this function does.\\n    User.prototype.create = function(...args){\\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\\n      var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\\n      var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\\n      \\n      var gun = this, cat = (gun._), root = gun.back(-1);\\n      cb = cb || noop;\\n      opt = opt || {};\\n      if(false !== opt.check){\\n        var err;\\n        if(!alias){ err = \\\"No user.\\\" }\\n        if((pass||'').length < 8){ err = \\\"Password too short!\\\" }\\n        if(err){\\n          cb({err: Gun.log(err)});\\n          return gun;\\n        }\\n      }\\n      if(cat.ing){\\n        (cb || noop)({err: Gun.log(\\\"User is already being created or authenticated!\\\"), wait: true});\\n        return gun;\\n      }\\n      cat.ing = true;\\n      var act = {}, u;\\n      act.a = function(pubs){\\n        act.pubs = pubs;\\n        if(pubs && !opt.already){\\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\\n          var ack = {err: Gun.log('User already created!')};\\n          cat.ing = false;\\n          (cb || noop)(ack);\\n          gun.leave();\\n          return;\\n        }\\n        act.salt = String.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\\n      }\\n      act.b = function(proof){\\n        act.proof = proof;\\n        pair ? act.c(pair) : SEA.pair(act.c) // generate a brand new key pair or use the existing.\\n      }\\n      act.c = function(pair){\\n        var tmp\\n        act.pair = pair || {};\\n        if(tmp = cat.root.user){\\n          tmp._.sea = pair;\\n          tmp.is = {pub: pair.pub, epub: pair.epub, alias: alias};\\n        }\\n        // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\\n        act.data = {pub: pair.pub};\\n        act.d();\\n      }\\n      act.d = function(){\\n        act.data.alias = alias;\\n        act.e();\\n      }\\n      act.e = function(){\\n        act.data.epub = act.pair.epub; \\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, act.proof, act.f, {raw:1}); // to keep the private key safe, we AES encrypt it with the proof of work!\\n      }\\n      act.f = function(auth){\\n        act.data.auth = JSON.stringify({ek: auth, s: act.salt}); \\n        act.g(act.data.auth);\\n      }\\n      act.g = function(auth){ var tmp;\\n        act.data.auth = act.data.auth || auth;\\n        root.get(tmp = '~'+act.pair.pub).put(act.data).on(act.h); // awesome, now we can actually save the user with their public key as their ID.\\n        var link = {}; link[tmp] = {'#': tmp}; root.get('~@'+alias).put(link).get(tmp).on(act.i); // next up, we want to associate the alias with the public key. So we add it to the alias list.\\n      }\\n      act.h = function(data, key, msg, eve){\\n        eve.off(); act.h.ok = 1; act.i();\\n      }\\n      act.i = function(data, key, msg, eve){\\n        if(eve){ act.i.ok = 1; eve.off() }\\n        if(!act.h.ok || !act.i.ok){ return }\\n        cat.ing = false;\\n        cb({ok: 0, pub: act.pair.pub}); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\\n        if(noop === cb){ pair ? gun.auth(pair) : gun.auth(alias, pass) } // if no callback is passed, auto-login after signing up.\\n      }\\n      root.get('~@'+alias).once(act.a);\\n      return gun;\\n    }\\n    User.prototype.leave = function(opt, cb){\\n      var gun = this, user = (gun.back(-1)._).user;\\n      if(user){\\n        delete user.is;\\n        delete user._.is;\\n        delete user._.sea;\\n      }\\n      if(SEA.window){\\n        try{var sS = {};\\n        sS = SEA.window.sessionStorage;\\n        delete sS.recall;\\n        delete sS.pair;\\n        }catch(e){};\\n      }\\n      return gun;\\n    }\\n  })(USE, './create');\\n\\n  ;USE(function(module){\\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\\n    // now that we have created a user, we want to authenticate them!\\n    User.prototype.auth = function(...args){ // TODO: this PR with arguments need to be cleaned up / refactored.\\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\\n      var alias = !pair && typeof args[0] === 'string' ? args[0] : null;\\n      var pass = (alias || (pair && !(pair.priv && pair.epriv))) && typeof args[1] === 'string' ? args[1] : null;\\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\\n      \\n      var gun = this, cat = (gun._), root = gun.back(-1);\\n      \\n      if(cat.ing){\\n        (cb || noop)({err: Gun.log(\\\"User is already being created or authenticated!\\\"), wait: true});\\n        return gun;\\n      }\\n      cat.ing = true;\\n      \\n      var act = {}, u, tries = 9;\\n      act.a = function(data){\\n        if(!data){ return act.b() }\\n        if(!data.pub){\\n          var tmp = []; Object.keys(data).forEach(function(k){ if('_'==k){ return } tmp.push(data[k]) })\\n          return act.b(tmp);\\n        }\\n        if(act.name){ return act.f(data) }\\n        act.c((act.data = data).auth);\\n      }\\n      act.b = function(list){\\n        var get = (act.list = (act.list||[]).concat(list||[])).shift();\\n        if(u === get){\\n          if(act.name){ return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.') }\\n          if(alias && tries--){\\n            root.get('~@'+alias).once(act.a);\\n            return;\\n          }\\n          return act.err('Wrong user or password.') \\n        }\\n        root.get(get).once(act.a);\\n      }\\n      act.c = function(auth){\\n        if(u === auth){ return act.b() }\\n        if('string' == typeof auth){ return act.c(obj_ify(auth)) } // in case of legacy\\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\\n      }\\n      act.d = function(proof){\\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\\n      }\\n      act.e = function(half){\\n        if(u === half){\\n          if(!act.enc){ // try old format\\n            act.enc = {encode: 'utf8'};\\n            return act.c(act.auth);\\n          } act.enc = null; // end backwards\\n          return act.b();\\n        }\\n        act.half = half;\\n        act.f(act.data);\\n      }\\n      act.f = function(pair){\\n        var half = act.half || {}, data = act.data || {};\\n        act.g(act.lol = {pub: pair.pub || data.pub, epub: pair.epub || data.epub, priv: pair.priv || half.priv, epriv: pair.epriv || half.epriv});\\n      }\\n      act.g = function(pair){\\n        if(!pair || !pair.pub || !pair.epub){ return act.b() }\\n        act.pair = pair;\\n        var user = (root._).user, at = (user._);\\n        var tmp = at.tag;\\n        var upt = at.opt;\\n        at = user._ = root.get('~'+pair.pub)._;\\n        at.opt = upt;\\n        // add our credentials in-memory only to our root user instance\\n        user.is = {pub: pair.pub, epub: pair.epub, alias: alias || pair.pub};\\n        at.sea = act.pair;\\n        cat.ing = false;\\n        try{if(pass && u == (obj_ify(cat.root.graph['~'+pair.pub].auth)||'')[':']){ opt.shuffle = opt.change = pass; } }catch(e){} // migrate UTF8 & Shuffle!\\n        opt.change? act.z() : (cb || noop)(at);\\n        if(SEA.window && ((gun.back('user')._).opt||opt).remember){\\n          // TODO: this needs to be modular.\\n          try{var sS = {};\\n          sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\\n          sS.recall = true;\\n          sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\\n          }catch(e){}\\n        }\\n        try{\\n          if(root._.tag.auth){ // auth handle might not be registered yet\\n          (root._).on('auth', at) // TODO: Deprecate this, emit on user instead! Update docs when you do.\\n          } else { setTimeout(function(){ (root._).on('auth', at) },1) } // if not, hackily add a timeout.\\n          //at.on('auth', at) // Arrgh, this doesn't work without event \\\"merge\\\" code, but \\\"merge\\\" code causes stack overflow and crashes after logging in & trying to write data.\\n        }catch(e){\\n          Gun.log(\\\"Your 'auth' callback crashed with:\\\", e);\\n        }\\n      }\\n      act.h = function(data){\\n        if(!data){ return act.b() }\\n        alias = data.alias\\n        if(!alias)\\n          alias = data.alias = \\\"~\\\" + pair.pub        \\n        if(!data.auth){\\n          return act.g(pair);\\n        }\\n        pair = null;\\n        act.c((act.data = data).auth);\\n      }\\n      act.z = function(){\\n        // password update so encrypt private key using new pwd + salt\\n        act.salt = String.random(64); // pseudo-random\\n        SEA.work(opt.change, act.salt, act.y);\\n      }\\n      act.y = function(proof){\\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, proof, act.x, {raw:1});\\n      }\\n      act.x = function(auth){\\n        act.w(JSON.stringify({ek: auth, s: act.salt}));\\n      }\\n      act.w = function(auth){\\n        if(opt.shuffle){ // delete in future!\\n          console.log('migrate core account from UTF8 & shuffle');\\n          var tmp = {}; Object.keys(act.data).forEach(function(k){ tmp[k] = act.data[k] });\\n          delete tmp._;\\n          tmp.auth = auth;\\n          root.get('~'+act.pair.pub).put(tmp);\\n        } // end delete\\n        root.get('~'+act.pair.pub).get('auth').put(auth, cb || noop);\\n      }\\n      act.err = function(e){\\n        var ack = {err: Gun.log(e || 'User cannot be found!')};\\n        cat.ing = false;\\n        (cb || noop)(ack);\\n      }\\n      act.plugin = function(name){\\n        if(!(act.name = name)){ return act.err() }\\n        var tmp = [name];\\n        if('~' !== name[0]){\\n          tmp[1] = '~'+name;\\n          tmp[2] = '~@'+name;\\n        }\\n        act.b(tmp);\\n      }\\n      if(pair){\\n        if(pair.priv && pair.epriv)\\n          act.g(pair);\\n        else\\n          root.get('~'+pair.pub).once(act.h);\\n      } else\\n      if(alias){\\n        root.get('~@'+alias).once(act.a);\\n      } else\\n      if(!alias && !pass){\\n        SEA.name(act.plugin);\\n      }\\n      return gun;\\n    }\\n    function obj_ify(o){\\n      if('string' != typeof o){ return o }\\n      try{o = JSON.parse(o);\\n      }catch(e){o={}};\\n      return o;\\n    }\\n  })(USE, './auth');\\n\\n  ;USE(function(module){\\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN;\\n    User.prototype.recall = function(opt, cb){\\n      var gun = this, root = gun.back(-1), tmp;\\n      opt = opt || {};\\n      if(opt && opt.sessionStorage){\\n        if(SEA.window){\\n          try{\\n            var sS = {};\\n            sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\\n            if(sS){\\n              (root._).opt.remember = true;\\n              ((gun.back('user')._).opt||opt).remember = true;\\n              if(sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\\n            }\\n          }catch(e){}\\n        }\\n        return gun;\\n      }\\n      /*\\n        TODO: copy mhelander's expiry code back in.\\n        Although, we should check with community,\\n        should expiry be core or a plugin?\\n      */\\n      return gun;\\n    }\\n  })(USE, './recall');\\n\\n  ;USE(function(module){\\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\\n    User.prototype.pair = function(){\\n      var user = this, proxy; // undeprecated, hiding with proxies.\\n      try{ proxy = new Proxy({DANGER:'\\\\u2620'}, {get: function(t,p,r){\\n        if(!user.is || !(user._||'').sea){ return }\\n        return user._.sea[p];\\n      }})}catch(e){}\\n      return proxy;\\n    }\\n    // If authenticated user wants to delete his/her account, let's support it!\\n    User.prototype.delete = async function(alias, pass, cb){\\n      console.log(\\\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\\\");\\n      var gun = this, root = gun.back(-1), user = gun.back('user');\\n      try {\\n        user.auth(alias, pass, function(ack){\\n          var pub = (user.is||{}).pub;\\n          // Delete user data\\n          user.map().once(function(){ this.put(null) });\\n          // Wipe user data from memory\\n          user.leave();\\n          (cb || noop)({ok: 0});\\n        });\\n      } catch (e) {\\n        Gun.log('User.delete failed! Error:', e);\\n      }\\n      return gun;\\n    }\\n    User.prototype.alive = async function(){\\n      console.log(\\\"user.alive() IS DEPRECATED!!!\\\");\\n      const gunRoot = this.back(-1)\\n      try {\\n        // All is good. Should we do something more with actual recalled data?\\n        await authRecall(gunRoot)\\n        return gunRoot._.user._\\n      } catch (e) {\\n        const err = 'No session!'\\n        Gun.log(err)\\n        throw { err }\\n      }\\n    }\\n    User.prototype.trust = async function(user){\\n      console.log(\\\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\\\");\\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\\n      //gun.get('alice').get('age').trust(bob);\\n      if (Gun.is(user)) {\\n        user.get('pub').get((ctx, ev) => {\\n          console.log(ctx, ev)\\n        })\\n      }\\n      user.get('trust').get(path).put(theirPubkey);\\n\\n      // do a lookup on this gun chain directly (that gets bob's copy of the data)\\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \\\"layers\\\")\\n      // THEN you perform Jachen's mix operation\\n      // and return the result of that to...\\n    }\\n    User.prototype.grant = function(to, cb){\\n      console.log(\\\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\\\");\\n      var gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';\\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\\n      (async function(){\\n      var enc, sec = await user.get('grant').get(pair.pub).get(path).then();\\n      sec = await SEA.decrypt(sec, pair);\\n      if(!sec){\\n        sec = SEA.random(16).toString();\\n        enc = await SEA.encrypt(sec, pair);\\n        user.get('grant').get(pair.pub).get(path).put(enc);\\n      }\\n      var pub = to.get('pub').then();\\n      var epub = to.get('epub').then();\\n      pub = await pub; epub = await epub;\\n      var dh = await SEA.secret(epub, pair);\\n      enc = await SEA.encrypt(sec, dh);\\n      user.get('grant').get(pub).get(path).put(enc, cb);\\n      }());\\n      return gun;\\n    }\\n    User.prototype.secret = function(data, cb){\\n      console.log(\\\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\\\");\\n      var gun = this, user = gun.back(-1).user(), pair = user.pair(), path = '';\\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\\n      (async function(){\\n      var enc, sec = await user.get('trust').get(pair.pub).get(path).then();\\n      sec = await SEA.decrypt(sec, pair);\\n      if(!sec){\\n        sec = SEA.random(16).toString();\\n        enc = await SEA.encrypt(sec, pair);\\n        user.get('trust').get(pair.pub).get(path).put(enc);\\n      }\\n      enc = await SEA.encrypt(data, sec);\\n      gun.put(enc, cb);\\n      }());\\n      return gun;\\n    }\\n\\n    /**\\n     * returns the decrypted value, encrypted by secret\\n     * @returns {Promise<any>}\\n     // Mark needs to review 1st before officially supported\\n    User.prototype.decrypt = function(cb) {\\n      let gun = this,\\n        path = ''\\n      gun.back(function(at) {\\n        if (at.is) {\\n          return\\n        }\\n        path += at.get || ''\\n      })\\n      return gun\\n        .then(async data => {\\n          if (data == null) {\\n            return\\n          }\\n          const user = gun.back(-1).user()\\n          const pair = user.pair()\\n          let sec = await user\\n            .get('trust')\\n            .get(pair.pub)\\n            .get(path)\\n          sec = await SEA.decrypt(sec, pair)\\n          if (!sec) {\\n            return data\\n          }\\n          let decrypted = await SEA.decrypt(data, sec)\\n          return decrypted\\n        })\\n        .then(res => {\\n          cb && cb(res)\\n          return res\\n        })\\n    }\\n    */\\n    module.exports = User\\n  })(USE, './share');\\n\\n  ;USE(function(module){\\n    var SEA = USE('./sea'), S = USE('./settings'), noop = function() {}, u;\\n    var Gun = (SEA.window||'').GUN || USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\\n    // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\\n\\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\\n    Gun.on('opt', function(at){\\n      if(!at.sea){ // only add SEA once per instance, on the \\\"at\\\" context.\\n        at.sea = {own: {}};\\n        at.on('put', check, at); // SEA now runs its firewall on HAM diffs, not all i/o.\\n      }\\n      this.to.next(at); // make sure to call the \\\"next\\\" middleware adapter.\\n    });\\n\\n    // Alright, this next adapter gets run at the per node level in the graph database.\\n    // correction: 2020 it gets run on each key/value pair in a node upon a HAM diff.\\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\\n    // If it does match, then we transform the in-memory \\\"view\\\" of the data into its plain value (without the signature).\\n    // Now NOTE! Some data is \\\"system\\\" data, not user data. Example: List of public keys, aliases, etc.\\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\\n    // Here is a problem: Multiple public keys can \\\"claim\\\" any node's ID, so this is dangerous!\\n    // This means we should ONLY trust our \\\"friends\\\" (our key ring) public keys, not any ones.\\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\\n\\n    function check(msg){ // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\\n      var eve = this, at = eve.as, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\\n      if(!soul || !key){ return }\\n      if((msg._||'').faith && (at.opt||'').faith && 'function' == typeof msg._){\\n        SEA.opt.pack(put, function(raw){\\n        SEA.verify(raw, false, function(data){ // this is synchronous if false\\n          put['='] = SEA.opt.unpack(data);\\n          eve.to.next(msg);\\n        })})\\n        return \\n      }\\n      var no = function(why){ at.on('in', {'@': id, err: msg.err = why}) }; // exploit internal relay stun for now, maybe violates spec, but testing for now. // Note: this may be only the sharded message, not original batch.\\n      //var no = function(why){ msg.ack(why) };\\n      (msg._||'').DBG && ((msg._||'').DBG.c = +new Date);\\n      if(0 <= soul.indexOf('<?')){ // special case for \\\"do not sync data X old\\\" forget\\n        // 'a~pub.key/b<?9'\\n        tmp = parseFloat(soul.split('<?')[1]||'');\\n        if(tmp && (state < (Gun.state() - (tmp * 1000)))){ // sec to ms\\n          (tmp = msg._) && (tmp.stun) && (tmp.stun--); // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\\n          return; // omit!\\n        }\\n      }\\n      \\n      if('~@' === soul){  // special case for shared system data, the list of aliases.\\n        check.alias(eve, msg, val, key, soul, at, no); return;\\n      }\\n      if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\\n        check.pubs(eve, msg, val, key, soul, at, no); return;\\n      }\\n      //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\\n      if(tmp = SEA.opt.pub(soul)){ // special case, account data for a public key.\\n        check.pub(eve, msg, val, key, soul, at, no, at.user||'', tmp); return;\\n      }\\n      if(0 <= soul.indexOf('#')){ // special case for content addressing immutable hashed data.\\n        check.hash(eve, msg, val, key, soul, at, no); return;\\n      } \\n      check.any(eve, msg, val, key, soul, at, no, at.user||''); return;\\n      eve.to.next(msg); // not handled\\n    }\\n    check.hash = function(eve, msg, val, key, soul, at, no){ // mark unbuilt @i001962 's epic hex contrib!\\n      SEA.work(val, null, function(data){\\n        function hexToBase64(hexStr) {\\n          let base64 = \\\"\\\";\\n          for(let i = 0; i < hexStr.length; i++) {\\n            base64 += !(i - 1 & 1) ? String.fromCharCode(parseInt(hexStr.substring(i - 1, i + 1), 16)) : \\\"\\\"}\\n          return btoa(base64);}  \\n        if(data && data === key.split('#').slice(-1)[0]){ return eve.to.next(msg) }\\n          else if (data && data === hexToBase64(key.split('#').slice(-1)[0])){ \\n          return eve.to.next(msg) }\\n        no(\\\"Data hash not same as hash!\\\");\\n      }, {name: 'SHA-256'});\\n    }\\n    check.alias = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@, ~@alice: {#~@alice}}\\n      if(!val){ return no(\\\"Data must exist!\\\") } // data MUST exist\\n      if('~@'+key === link_is(val)){ return eve.to.next(msg) } // in fact, it must be EXACTLY equal to itself\\n      no(\\\"Alias not same!\\\"); // if it isn't, reject.\\n    };\\n    check.pubs = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\\n      if(!val){ return no(\\\"Alias must exist!\\\") } // data MUST exist\\n      if(key === link_is(val)){ return eve.to.next(msg) } // and the ID must be EXACTLY equal to its property\\n      no(\\\"Alias not same!\\\"); // that way nobody can tamper with the list of public keys.\\n    };\\n    check.pub = async function(eve, msg, val, key, soul, at, no, user, pub){ var tmp // Example: {_:#~asdf, hello:'world'~fdsa}}\\n      const raw = await S.parse(val) || {}\\n      const verify = (certificate, certificant, cb) => {\\n        if (certificate.m && certificate.s && certificant && pub)\\n          // now verify certificate\\n          return SEA.verify(certificate, pub, data => { // check if \\\"pub\\\" (of the graph owner) really issued this cert\\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\\\"Certificate expired.\\\") // certificate expired\\n            // \\\"data.c\\\" = a list of certificants/certified users\\n            // \\\"data.w\\\" = lex WRITE permission, in the future, there will be \\\"data.r\\\" which means lex READ permission\\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\\n              // ok, now \\\"certificant\\\" is in the \\\"certificants\\\" list, but is \\\"path\\\" allowed? Check path\\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : ''\\n              String.match = String.match || Gun.text.match\\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : []\\n              for (const lex of w) {\\n                if ((String.match(path, lex['#']) && String.match(key, lex['.'])) || (!lex['.'] && String.match(path, lex['#'])) || (!lex['#'] && String.match(key, lex['.'])) || String.match((path ? path + '/' + key : key), lex['#'] || lex)) {\\n                  // is Certificant forced to present in Path\\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \\\"${path}\\\" or key \\\"${key}\\\" must contain string \\\"${certificant}\\\".`)\\n                  // path is allowed, but is there any WRITE block? Check it out\\n                  if (data.wb && (typeof data.wb === 'string' || ((data.wb || {})['#']))) { // \\\"data.wb\\\" = path to the WRITE block\\n                    var root = eve.as.root.$.back(-1)\\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub)\\n                    return root.get(data.wb).get(certificant).once(value => { // TODO: INTENT TO DEPRECATE.\\n                      if (value && (value === 1 || value === true)) return no(`Certificant ${certificant} blocked.`)\\n                      return cb(data)\\n                    })\\n                  }\\n                  return cb(data)\\n                }\\n              }\\n              return no(\\\"Certificate verification fail.\\\")\\n            }\\n          })\\n        return\\n      }\\n      \\n      if ('pub' === key && '~' + pub === soul) {\\n        if (val === pub) return eve.to.next(msg) // the account MUST match `pub` property that equals the ID of the public key.\\n        return no(\\\"Account not same!\\\")\\n      }\\n\\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || (pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert))){\\n        SEA.opt.pack(msg.put, packed => {\\n          SEA.sign(packed, (user._).sea, async function(data) {\\n            if (u === data) return no(SEA.err || 'Signature fail.')\\n            msg.put[':'] = {':': tmp = SEA.opt.unpack(data.m), '~': data.s}\\n            msg.put['='] = tmp\\n  \\n            // if writing to own graph, just allow it\\n            if (pub === user.is.pub) {\\n              if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\\n              JSON.stringifyAsync(msg.put[':'], function(err,s){\\n                if(err){ return no(err || \\\"Stringify error.\\\") }\\n                msg.put[':'] = s;\\n                return eve.to.next(msg);\\n              })\\n              return\\n            }\\n  \\n            // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\\n            if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {\\n              const cert = await S.parse(msg._.msg.opt.cert)\\n              // even if cert exists, we must verify it\\n              if (cert && cert.m && cert.s)\\n                verify(cert, user.is.pub, _ => {\\n                  msg.put[':']['+'] = cert // '+' is a certificate\\n                  msg.put[':']['*'] = user.is.pub // '*' is pub of the user who puts\\n                  JSON.stringifyAsync(msg.put[':'], function(err,s){\\n                    if(err){ return no(err || \\\"Stringify error.\\\") }\\n                    msg.put[':'] = s;\\n                    return eve.to.next(msg);\\n                  })\\n                  return\\n                })\\n            }\\n          }, {raw: 1})\\n        })\\n        return;\\n      }\\n\\n      SEA.opt.pack(msg.put, packed => {\\n        SEA.verify(packed, raw['*'] || pub, function(data){ var tmp;\\n          data = SEA.opt.unpack(data);\\n          if (u === data) return no(\\\"Unverified data.\\\") // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\\n          if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\\n          \\n          // check if cert ('+') and putter's pub ('*') exist\\n          if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*'])\\n            // now verify certificate\\n            verify(raw['+'], raw['*'], _ => {\\n              msg.put['='] = data;\\n              return eve.to.next(msg);\\n            })\\n          else {\\n            msg.put['='] = data;\\n            return eve.to.next(msg);\\n          }\\n        });\\n      })\\n      return\\n    };\\n    check.any = function(eve, msg, val, key, soul, at, no, user){ var tmp, pub;\\n      if(at.opt.secure){ return no(\\\"Soul missing public key at '\\\" + key + \\\"'.\\\") }\\n      // TODO: Ask community if should auto-sign non user-graph data.\\n      at.on('secure', function(msg){ this.off();\\n        if(!at.opt.secure){ return eve.to.next(msg) }\\n        no(\\\"Data cannot be changed.\\\");\\n      }).on.on('secure', msg);\\n      return;\\n    }\\n\\n    var valid = Gun.valid, link_is = function(d,l){ return 'string' == typeof (l = valid(d)) && l }, state_ify = (Gun.state||'').ify;\\n\\n    var pubcut = /[^\\\\w_-]/; // anything not alphanumeric or _ -\\n    SEA.opt.pub = function(s){\\n      if(!s){ return }\\n      s = s.split('~');\\n      if(!s || !(s = s[1])){ return }\\n      s = s.split(pubcut).slice(0,2);\\n      if(!s || 2 != s.length){ return }\\n      if('@' === (s[0]||'')[0]){ return }\\n      s = s.slice(0,2).join('.');\\n      return s;\\n    }\\n    SEA.opt.stringy = function(t){\\n      // TODO: encrypt etc. need to check string primitive. Make as breaking change.\\n    }\\n    SEA.opt.pack = function(d,cb,k, n,s){ var tmp, f; // pack for verifying\\n      if(SEA.opt.check(d)){ return cb(d) }\\n      if(d && d['#'] && d['.'] && d['>']){ tmp = d[':']; f = 1 }\\n      JSON.parseAsync(f? tmp : d, function(err, meta){\\n        var sig = ((u !== (meta||'')[':']) && (meta||'')['~']); // or just ~ check?\\n        if(!sig){ cb(d); return }\\n        cb({m: {'#':s||d['#'],'.':k||d['.'],':':(meta||'')[':'],'>':d['>']||Gun.state.is(n, k)}, s: sig});\\n      });\\n    }\\n    var O = SEA.opt;\\n    SEA.opt.unpack = function(d, k, n){ var tmp;\\n      if(u === d){ return }\\n      if(d && (u !== (tmp = d[':']))){ return tmp }\\n      k = k || O.fall_key; if(!n && O.fall_val){ n = {}; n[k] = O.fall_val }\\n      if(!k || !n){ return }\\n      if(d === n[k]){ return d }\\n      if(!SEA.opt.check(n[k])){ return d }\\n      var soul = (n && n._ && n._['#']) || O.fall_soul, s = Gun.state.is(n, k) || O.fall_state;\\n      if(d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])){\\n        return d[2];\\n      }\\n      if(s < SEA.opt.shuffle_attack){\\n        return d;\\n      }\\n    }\\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\\n\\n  })(USE, './index');\\n}());\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Buffer\",\"USE\",\"arg\",\"req\",\"slice\",\"split\",\"toString\",\"replace\",\"mod\",\"path\",\"MODULE\",\"self\",\"window\",\"SEA\",\"e\",\"location\",\"protocol\",\"indexOf\",\"host\",\"test\",\"hostname\",\"console\",\"warn\",\"btoa\",\"log\",\"global.btoa\",\"data\",\"from\",\"atob\",\"global.atob\",\"SeaArray\",\"Object\",\"assign\",\"Array\",\"prototype\",\"create\",\"SeaArray.prototype.toString\",\"enc\",\"start\",\"end\",\"length\",\"buf\",\"Uint8Array\",\"keys\",\"map\",\"i\",\"padStart\",\"join\",\"_\",\"String\",\"fromCharCode\",\"SafeBuffer\",\"props\",\"arguments\",\"TypeError\",\"input\",\"bytes\",\"match\",\"byte\",\"parseInt\",\"words\",\"Uint16Array\",\"charCodeAt\",\"dec\",\"info\",\"byteLength\",\"ArrayBuffer\",\"alloc\",\"fill\",\"allocUnsafe\",\"concat\",\"arr\",\"isArray\",\"reduce\",\"ret\",\"item\",\"api\",\"o\",\"JSON\",\"parseAsync\",\"t\",\"cb\",\"r\",\"u\",\"parse\",\"stringifyAsync\",\"v\",\"s\",\"stringify\",\"api.parse\",\"Promise\",\"res\",\"rej\",\"err\",\"raw\",\"api.stringify\",\"crypto\",\"msCrypto\",\"subtle\",\"webkitSubtle\",\"TextEncoder\",\"TextDecoder\",\"random\",\"len\",\"api.random\",\"getRandomValues\",\"randomBytes\",\"WebCrypto\",\"ossl\",\"directory\",\"shim\",\"hash\",\"name\",\"iter\",\"ks\",\"pair\",\"namedCurve\",\"sign\",\"s.jwk\",\"pub\",\"d\",\"jwk\",\"kty\",\"crv\",\"x\",\"y\",\"ext\",\"key_ops\",\"s.keyToJwk\",\"keyBytes\",\"k\",\"keyB64\",\"alg\",\"validity\",\"hook\",\"s.check\",\"s.parse\",\"yes\",\"opt\",\"module.exports\",\"digest\",\"encode\",\"__shim\",\"b\",\"sha1hash\",\"S\",\"sha\",\"work\",\"salt\",\"epub\",\"Function\",\"toLowerCase\",\"rsha\",\"key\",\"importKey\",\"deriveBits\",\"iterations\",\"pbkdf2\",\"throw\",\"ecdhSubtle\",\"sa\",\"generateKey\",\"then\",\"priv\",\"exportKey\",\"privateKey\",\"publicKey\",\"dh\",\"epriv\",\"I\",\"what\",\"how\",\"why\",\"json\",\"check\",\"verify\",\"m\",\"sig\",\"slow_leak\",\"fallback\",\"fall_verify\",\"knownKeys\",\"SEA.opt.slow_leak\",\"O\",\"SEA.opt.fall_verify\",\"f\",\"tmp\",\"unpack\",\"fall_soul\",\"fall_key\",\"fall_val\",\"fall_state\",\"sha256hash\",\"importGen\",\"combo\",\"jwkKey\",\"keyToJwk\",\"aeskey\",\"encrypt\",\"msg\",\"ct\",\"aes\",\"iv\",\"decrypt\",\"bufiv\",\"bufct\",\"tagLength\",\"decode\",\"secret\",\"pubKeyData\",\"keysToEcdhJwk\",\"public\",\"privKeyData\",\"derived\",\"privKey\",\"derivedBits\",\"rawBits\",\"derivedKey\",\"certify\",\"certificants\",\"policy\",\"authority\",\"certificant\",\"push\",\"expiry\",\"parseFloat\",\"readPolicy\",\"read\",\"writePolicy\",\"write\",\"block\",\"blacklist\",\"ban\",\"readBlock\",\"writeBlock\",\"c\",\"w\",\"rb\",\"wb\",\"certificate\",\"keyid\",\"pb\",\"id\",\"sha1\",\"GUN\",\"User\",\"root\",\"$\",\"lex\",\"Gun\",\"state\",\"chain\",\"F\",\"constructor\",\"user\",\"Gun.chain.user\",\"gun\",\"back\",\"get\",\"at\",\"uuid\",\"at.opt.uuid\",\"is\",\"call\",\"Gun.chain.then\",\"p\",\"once\",\"noop\",\"User.prototype.create\",\"args\",\"alias\",\"pass\",\"filter\",\"cat\",\"ing\",\"wait\",\"act\",\"act.a\",\"pubs\",\"already\",\"ack\",\"leave\",\"act.b\",\"proof\",\"act.c\",\"sea\",\"act.d\",\"act.e\",\"act.f\",\"auth\",\"ek\",\"g\",\"act.g\",\"put\",\"on\",\"h\",\"link\",\"act.h\",\"eve\",\"off\",\"ok\",\"act.i\",\"a\",\"User.prototype.leave\",\"sS\",\"sessionStorage\",\"recall\",\"obj_ify\",\"User.prototype.auth\",\"tries\",\"forEach\",\"list\",\"shift\",\"half\",\"lol\",\"upt\",\"graph\",\"shuffle\",\"change\",\"z\",\"remember\",\"tag\",\"setTimeout\",\"act.z\",\"act.y\",\"act.x\",\"act.w\",\"act.err\",\"plugin\",\"act.plugin\",\"User.prototype.recall\",\"User.prototype.pair\",\"proxy\",\"Proxy\",\"DANGER\",\"delete\",\"User.prototype.delete\",\"alive\",\"User.prototype.alive\",\"gunRoot\",\"authRecall\",\"trust\",\"User.prototype.trust\",\"ctx\",\"ev\",\"theirPubkey\",\"grant\",\"User.prototype.grant\",\"to\",\"sec\",\"User.prototype.secret\",\"as\",\"soul\",\"val\",\"faith\",\"pack\",\"next\",\"no\",\"DBG\",\"Date\",\"stun\",\"any\",\"own\",\"check.hash\",\"base64\",\"hexStr\",\"substring\",\"check.alias\",\"link_is\",\"check.pubs\",\"check.pub\",\"text\",\"value\",\"cert\",\"packed\",\"check.any\",\"secure\",\"valid\",\"l\",\"pubcut\",\"SEA.opt.pub\",\"stringy\",\"SEA.opt.stringy\",\"SEA.opt.pack\",\"n\",\"meta\",\"SEA.opt.unpack\",\"fl\",\"shuffle_attack\",\"Math\",\"floor\"]\n}\n"]