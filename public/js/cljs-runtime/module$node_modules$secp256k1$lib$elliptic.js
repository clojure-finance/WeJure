shadow$provide.module$node_modules$secp256k1$lib$elliptic=function(global,require,module,exports){function loadPublicKey(pubkey){var first=pubkey[0];switch(first){case 2:case 3:if(33!==pubkey.length)return null;var xbuf=pubkey.subarray(1,33);pubkey=new BN(xbuf);0<=pubkey.cmp(ecparams.p)?first=null:(pubkey=pubkey.toRed(ecparams.red),xbuf=pubkey.redSqr().redIMul(pubkey).redIAdd(ecparams.b).redSqrt(),3===first!==xbuf.isOdd()&&(xbuf=xbuf.redNeg()),first=ec.keyPair({pub:{x:pubkey,y:xbuf}}));return first;
case 4:case 6:case 7:if(65!==pubkey.length)return null;xbuf=pubkey.subarray(1,33);pubkey=pubkey.subarray(33,65);xbuf=new BN(xbuf);pubkey=new BN(pubkey);0<=xbuf.cmp(ecparams.p)||0<=pubkey.cmp(ecparams.p)?first=null:(xbuf=xbuf.toRed(ecparams.red),pubkey=pubkey.toRed(ecparams.red),6!==first&&7!==first||pubkey.isOdd()===(7===first)?(first=xbuf.redSqr().redIMul(xbuf),first=pubkey.redSqr().redISub(first.redIAdd(ecparams.b)).isZero()?ec.keyPair({pub:{x:xbuf,y:pubkey}}):null):first=null);return first;default:return null}}
function savePublicKey(output,point){point=point.encode(null,33===output.length);for(let i=0;i<output.length;++i)output[i]=point[i]}const ec=new (require("module$node_modules$elliptic$lib$elliptic").ec)("secp256k1"),ecparams=ec.curve,BN=ecparams.n.constructor;module.exports={contextRandomize(){return 0},privateKeyVerify(seckey){seckey=new BN(seckey);return 0>seckey.cmp(ecparams.n)&&!seckey.isZero()?0:1},privateKeyNegate(seckey){var bn=new BN(seckey);bn=ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array,
"be",32);seckey.set(bn);return 0},privateKeyTweakAdd(seckey,tweak){tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n))return 1;tweak.iadd(new BN(seckey));0<=tweak.cmp(ecparams.n)&&tweak.isub(ecparams.n);if(tweak.isZero())return 1;tweak=tweak.toArrayLike(Uint8Array,"be",32);seckey.set(tweak);return 0},privateKeyTweakMul(seckey,tweak){tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n)||tweak.isZero())return 1;tweak.imul(new BN(seckey));0<=tweak.cmp(ecparams.n)&&(tweak=tweak.umod(ecparams.n));tweak=tweak.toArrayLike(Uint8Array,
"be",32);seckey.set(tweak);return 0},publicKeyVerify(pubkey){return null===loadPublicKey(pubkey)?1:0},publicKeyCreate(output,seckey){const bn=new BN(seckey);if(0<=bn.cmp(ecparams.n)||bn.isZero())return 1;seckey=ec.keyFromPrivate(seckey).getPublic();savePublicKey(output,seckey);return 0},publicKeyConvert(output,pubkey){pubkey=loadPublicKey(pubkey);if(null===pubkey)return 1;pubkey=pubkey.getPublic();savePublicKey(output,pubkey);return 0},publicKeyNegate(output,pubkey){pubkey=loadPublicKey(pubkey);if(null===
pubkey)return 1;pubkey=pubkey.getPublic();pubkey.y=pubkey.y.redNeg();savePublicKey(output,pubkey);return 0},publicKeyCombine(output,pubkeys){const pairs=Array(pubkeys.length);for(var i=0;i<pubkeys.length;++i)if(pairs[i]=loadPublicKey(pubkeys[i]),null===pairs[i])return 1;pubkeys=pairs[0].getPublic();for(i=1;i<pairs.length;++i)pubkeys=pubkeys.add(pairs[i].pub);if(pubkeys.isInfinity())return 2;savePublicKey(output,pubkeys);return 0},publicKeyTweakAdd(output,pubkey,tweak){pubkey=loadPublicKey(pubkey);
if(null===pubkey)return 1;tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n))return 2;tweak=pubkey.getPublic().add(ecparams.g.mul(tweak));if(tweak.isInfinity())return 2;savePublicKey(output,tweak);return 0},publicKeyTweakMul(output,pubkey,tweak){pubkey=loadPublicKey(pubkey);if(null===pubkey)return 1;tweak=new BN(tweak);if(0<=tweak.cmp(ecparams.n)||tweak.isZero())return 2;tweak=pubkey.getPublic().mul(tweak);savePublicKey(output,tweak);return 0},signatureNormalize(sig){const r=new BN(sig.subarray(0,32)),
s=new BN(sig.subarray(32,64));if(0<=r.cmp(ecparams.n)||0<=s.cmp(ecparams.n))return 1;1===s.cmp(ec.nh)&&sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array,"be",32),32);return 0},signatureExport(obj,sig){var sigR=sig.subarray(0,32),sigS=sig.subarray(32,64);if(0<=(new BN(sigR)).cmp(ecparams.n)||0<=(new BN(sigS)).cmp(ecparams.n))return 1;({output:sig}=obj);let r=sig.subarray(4,37);r[0]=0;r.set(sigR,1);sigR=33;for(var posR=0;1<sigR&&0===r[posR]&&!(r[posR+1]&128);--sigR,++posR);r=r.subarray(posR);if(r[0]&
128||1<sigR&&0===r[0]&&!(r[1]&128))return 1;posR=sig.subarray(39,72);posR[0]=0;posR.set(sigS,1);sigS=33;let posS=0;for(;1<sigS&&0===posR[posS]&&!(posR[posS+1]&128);--sigS,++posS);posR=posR.subarray(posS);if(posR[0]&128||1<sigS&&0===posR[0]&&!(posR[1]&128))return 1;obj.outputlen=6+sigR+sigS;sig[0]=48;sig[1]=obj.outputlen-2;sig[2]=2;sig[3]=r.length;sig.set(r,4);sig[4+sigR]=2;sig[5+sigR]=posR.length;sig.set(posR,6+sigR);return 0},signatureImport(output,sig){if(8>sig.length||72<sig.length||48!==sig[0]||
sig[1]!==sig.length-2||2!==sig[2])return 1;const lenR=sig[3];if(0===lenR||5+lenR>=sig.length||2!==sig[4+lenR])return 1;var lenS=sig[5+lenR];if(0===lenS||6+lenR+lenS!==sig.length||sig[4]&128||1<lenR&&0===sig[4]&&!(sig[5]&128)||sig[lenR+6]&128||1<lenS&&0===sig[lenR+6]&&!(sig[lenR+7]&128))return 1;lenS=sig.subarray(4,4+lenR);33===lenS.length&&0===lenS[0]&&(lenS=lenS.subarray(1));if(32<lenS.length)return 1;let sigS=sig.subarray(6+lenR);33===sigS.length&&0===sigS[0]&&(sigS=sigS.slice(1));if(32<sigS.length)throw Error("S length is too long");
lenS=new BN(lenS);0<=lenS.cmp(ecparams.n)&&(lenS=new BN(0));sig=new BN(sig.subarray(6+lenR));0<=sig.cmp(ecparams.n)&&(sig=new BN(0));output.set(lenS.toArrayLike(Uint8Array,"be",32),0);output.set(sig.toArrayLike(Uint8Array,"be",32),32);return 0},ecdsaSign(obj,message,seckey,data,noncefn){if(noncefn){const _noncefn=noncefn;noncefn=counter=>{counter=_noncefn(message,seckey,null,data,counter);if(!(counter instanceof Uint8Array&&32===counter.length))throw Error("This is the way");return new BN(counter)}}const d=
new BN(seckey);if(0<=d.cmp(ecparams.n)||d.isZero())return 1;let sig;try{sig=ec.sign(message,seckey,{canonical:!0,k:noncefn,pers:data})}catch(err){return 1}obj.signature.set(sig.r.toArrayLike(Uint8Array,"be",32),0);obj.signature.set(sig.s.toArrayLike(Uint8Array,"be",32),32);obj.recid=sig.recoveryParam;return 0},ecdsaVerify(sig,msg32,pubkey){sig={r:sig.subarray(0,32),s:sig.subarray(32,64)};const sigr=new BN(sig.r),sigs=new BN(sig.s);if(0<=sigr.cmp(ecparams.n)||0<=sigs.cmp(ecparams.n))return 1;if(1===
sigs.cmp(ec.nh)||sigr.isZero()||sigs.isZero())return 3;pubkey=loadPublicKey(pubkey);if(null===pubkey)return 2;pubkey=pubkey.getPublic();return ec.verify(msg32,sig,pubkey)?0:3},ecdsaRecover(output,sig,recid,msg32){sig={r:sig.slice(0,32),s:sig.slice(32,64)};const sigr=new BN(sig.r),sigs=new BN(sig.s);if(0<=sigr.cmp(ecparams.n)||0<=sigs.cmp(ecparams.n))return 1;if(sigr.isZero()||sigs.isZero())return 2;let point;try{point=ec.recoverPubKey(msg32,sig,recid)}catch(err){return 2}savePublicKey(output,point);
return 0},ecdh(output,pubkey,seckey,data,hashfn,xbuf,ybuf){pubkey=loadPublicKey(pubkey);if(null===pubkey)return 1;seckey=new BN(seckey);if(0<=seckey.cmp(ecparams.n)||seckey.isZero())return 2;seckey=pubkey.getPublic().mul(seckey);if(void 0===hashfn)for(data=seckey.encode(null,!0),data=ec.hash().update(data).digest(),hashfn=0;32>hashfn;++hashfn)output[hashfn]=data[hashfn];else{xbuf||(xbuf=new Uint8Array(32));pubkey=seckey.getX().toArray("be",32);for(let i=0;32>i;++i)xbuf[i]=pubkey[i];ybuf||(ybuf=new Uint8Array(32));
seckey=seckey.getY().toArray("be",32);for(pubkey=0;32>pubkey;++pubkey)ybuf[pubkey]=seckey[pubkey];data=hashfn(xbuf,ybuf,data);if(!(data instanceof Uint8Array&&data.length===output.length))return 2;output.set(data)}return 0}}}
//# sourceMappingURL=module$node_modules$secp256k1$lib$elliptic.js.map
