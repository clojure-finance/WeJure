{
"version":3,
"file":"module$node_modules$web3_eth_abi$lib$index.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/web3-eth-abi/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$web3_eth_abi$lib$index\"] = function(global,require,module,exports) {\n/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = require('buffer').Buffer;\nvar utils = require('web3-utils');\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Result","Buffer","utils","EthersAbiCoder","AbiCoder","ParamType","ethersAbiCoder","type","value","match","Array","isArray","constructor","name","toString","ABICoder","prototype","encodeFunctionSignature","ABICoder.prototype.encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","ABICoder.prototype.encodeEventSignature","encodeParameter","ABICoder.prototype.encodeParameter","param","encodeParameters","ABICoder.prototype.encodeParameters","types","params","self","mapTypes","map","index","formatParam","includes","coder","_getCoder","from","modifyParams","p","replace","coders","forEach","c","i","encode","ABICoder.prototype.mapTypes","mappedTypes","Object","assign","isSimplifiedStructFormat","structName","keys","push","mapStructNameAndType","components","mapStructToCoderFormat","ABICoder.prototype.isSimplifiedStructFormat","ABICoder.prototype.mapStructNameAndType","indexOf","ABICoder.prototype.mapStructToCoderFormat","struct","key","ABICoder.prototype.formatParam","paramTypeBytes","RegExp","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","parseInt","length","leftPad","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionCall","ABICoder.prototype.encodeFunctionCall","jsonInterface","inputs","decodeParameter","ABICoder.prototype.decodeParameter","bytes","decodeParameters","ABICoder.prototype.decodeParameters","outputs","decodeParametersWith","ABICoder.prototype.decodeParametersWith","loose","Error","res","decode","returnValue","__length__","output","decodedValue","decodeLog","ABICoder.prototype.decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","notIndexedParams","nonIndexedData"]
}
