{
"version":3,
"file":"module$node_modules$multihashes$src$index.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/multihashes/src/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$multihashes$src$index\"] = function(global,require,module,exports) {\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst cs = require('./constants')\n\nexports.names = cs.names\nexports.codes = cs.codes\nexports.defaultLengths = cs.defaultLengths\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return hash.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return multibase.encode('base58btc', hash).toString().slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  let encoded = hash\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString()\n  }\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (buf) {\n  if (!(Buffer.isBuffer(buf))) {\n    throw new Error('multihash must be a Buffer')\n  }\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(Buffer.isBuffer(digest))) {\n    throw new Error('digest should be a Buffer')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  return Buffer.concat([\n    Buffer.from(varint.encode(hashfn)),\n    Buffer.from(varint.encode(length)),\n    digest\n  ])\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = cs.names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (cs.codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return multihash.slice(0, 2)\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","validate","multihash","decode","Buffer","multibase","varint","cs","names","codes","defaultLengths","toHexString","exports.toHexString","hash","isBuffer","Error","toString","fromHexString","exports.fromHexString","from","toB58String","exports.toB58String","encode","slice","fromB58String","exports.fromB58String","encoded","exports.decode","buf","length","code","isValidCode","bytes","len","name","digest","exports.encode","undefined","hashfn","coerceCode","concat","exports.coerceCode","isAppCode","exports.isAppCode","exports.isValidCode","prefix","exports.prefix"]
}
