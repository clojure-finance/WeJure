{
"version":3,
"file":"module$node_modules$secp256k1$lib$index.js",
"lineCount":16,
"mappings":"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",
"sources":["node_modules/secp256k1/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$secp256k1$lib$index\"] = function(global,require,module,exports) {\nconst errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","len","Object","prototype","toString","call","slice","secp256k1","module.exports","contextRandomize","seed","CONTEXT_RANDOMIZE_UNKNOW","privateKeyVerify","seckey","privateKeyNegate","IMPOSSIBLE_CASE","privateKeyTweakAdd","tweak","TWEAK_ADD","privateKeyTweakMul","TWEAK_MUL","publicKeyVerify","pubkey","publicKeyCreate","compressed","SECKEY_INVALID","PUBKEY_SERIALIZE","publicKeyConvert","PUBKEY_PARSE","publicKeyNegate","publicKeyCombine","pubkeys","PUBKEY_COMBINE","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","SIG_PARSE","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","SIGN","ecdsaVerify","ecdsaRecover","RECOVER","ecdh","hashfn","xbuf","ybuf","ECDH"]
}
