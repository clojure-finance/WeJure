shadow$provide.module$node_modules$ethereumjs_util$dist_browser$address=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.Address=void 0;var assert_1=global(require("module$node_modules$assert$assert")),externals_1=require("module$node_modules$ethereumjs_util$dist_browser$externals"),
bytes_1=require("module$node_modules$ethereumjs_util$dist_browser$bytes"),account_1=require("module$node_modules$ethereumjs_util$dist_browser$account");require=function(){function Address(buf){(0,assert_1.default)(20===buf.length,"Invalid address length");this.buf=buf}Address.zero=function(){return new Address((0,bytes_1.zeros)(20))};Address.fromString=function(str){(0,assert_1.default)((0,account_1.isValidAddress)(str),"Invalid address");return new Address((0,bytes_1.toBuffer)(str))};Address.fromPublicKey=
function(pubKey){(0,assert_1.default)(Buffer.isBuffer(pubKey),"Public key should be Buffer");pubKey=(0,account_1.pubToAddress)(pubKey);return new Address(pubKey)};Address.fromPrivateKey=function(privateKey){(0,assert_1.default)(Buffer.isBuffer(privateKey),"Private key should be Buffer");privateKey=(0,account_1.privateToAddress)(privateKey);return new Address(privateKey)};Address.generate=function(from,nonce){(0,assert_1.default)(externals_1.BN.isBN(nonce));return new Address((0,account_1.generateAddress)(from.buf,
nonce.toArrayLike(Buffer)))};Address.generate2=function(from,salt,initCode){(0,assert_1.default)(Buffer.isBuffer(salt));(0,assert_1.default)(Buffer.isBuffer(initCode));return new Address((0,account_1.generateAddress2)(from.buf,salt,initCode))};Address.prototype.equals=function(address){return this.buf.equals(address.buf)};Address.prototype.isZero=function(){return this.equals(Address.zero())};Address.prototype.isPrecompileOrSystemAddress=function(){var addressBN=new externals_1.BN(this.buf),rangeMin=
new externals_1.BN(0),rangeMax=new externals_1.BN("ffff","hex");return addressBN.gte(rangeMin)&&addressBN.lte(rangeMax)};Address.prototype.toString=function(){return"0x"+this.buf.toString("hex")};Address.prototype.toBuffer=function(){return Buffer.from(this.buf)};return Address}();exports.Address=require}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist_browser$address.js.map
