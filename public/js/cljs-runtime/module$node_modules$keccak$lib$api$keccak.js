shadow$provide.module$node_modules$keccak$lib$api$keccak=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;const {Transform}=require("module$node_modules$keccak$node_modules$readable_stream$readable_browser");module.exports=KeccakState=>class Keccak extends Transform{constructor(rate,capacity,delimitedSuffix,hashBitLength,options){super(options);this._rate=rate;this._capacity=capacity;this._delimitedSuffix=delimitedSuffix;this._hashBitLength=hashBitLength;
this._options=options;this._state=new KeccakState;this._state.initialize(rate,capacity);this._finalized=!1}_transform(chunk,encoding,callback){let error=null;try{this.update(chunk,encoding)}catch(err){error=err}callback(error)}_flush(callback){let error=null;try{this.push(this.digest())}catch(err){error=err}callback(error)}update(data,encoding){if(!Buffer.isBuffer(data)&&"string"!==typeof data)throw new TypeError("Data must be a string or a buffer");if(this._finalized)throw Error("Digest already called");
Buffer.isBuffer(data)||(data=Buffer.from(data,encoding));this._state.absorb(data);return this}digest(encoding){if(this._finalized)throw Error("Digest already called");this._finalized=!0;this._delimitedSuffix&&this._state.absorbLastFewBits(this._delimitedSuffix);let digest=this._state.squeeze(this._hashBitLength/8);void 0!==encoding&&(digest=digest.toString(encoding));this._resetState();return digest}_resetState(){this._state.initialize(this._rate,this._capacity);return this}_clone(){const clone=new Keccak(this._rate,
this._capacity,this._delimitedSuffix,this._hashBitLength,this._options);this._state.copy(clone._state);clone._finalized=this._finalized;return clone}}}
//# sourceMappingURL=module$node_modules$keccak$lib$api$keccak.js.map
