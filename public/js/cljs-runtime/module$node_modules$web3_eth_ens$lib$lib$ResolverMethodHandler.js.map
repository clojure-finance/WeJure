{
"version":3,
"file":"module$node_modules$web3_eth_ens$lib$lib$ResolverMethodHandler.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$web3_eth_ens$lib$lib$ResolverMethodHandler\"] = function(global,require,module,exports) {\n/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file ResolverMethodHandler.js\n *\n * @author Samuel Furter <samuel@ethereum.org>\n * @date 2018\n */\n\"use strict\";\nvar PromiEvent = require('web3-core-promievent');\nvar namehash = require('eth-ens-namehash');\nvar errors = require('web3-core-helpers').errors;\nvar interfaceIds = require('../config').interfaceIds;\n/**\n * @param {Registry} registry\n * @constructor\n */\nfunction ResolverMethodHandler(registry) {\n    this.registry = registry;\n}\n/**\n * Executes an resolver method and returns an eventifiedPromise\n *\n * @param {string} ensName\n * @param {string} methodName\n * @param {array} methodArguments\n * @param {function} callback\n * @returns {Object}\n */\nResolverMethodHandler.prototype.method = function (ensName, methodName, methodArguments, outputFormatter, callback) {\n    return {\n        call: this.call.bind({\n            ensName: ensName,\n            methodName: methodName,\n            methodArguments: methodArguments,\n            callback: callback,\n            parent: this,\n            outputFormatter: outputFormatter\n        }),\n        send: this.send.bind({\n            ensName: ensName,\n            methodName: methodName,\n            methodArguments: methodArguments,\n            callback: callback,\n            parent: this\n        })\n    };\n};\n/**\n * Executes call\n *\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.call = function (callback) {\n    var self = this;\n    var promiEvent = new PromiEvent();\n    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);\n    var outputFormatter = this.outputFormatter || null;\n    this.parent.registry.getResolver(this.ensName).then(async function (resolver) {\n        await self.parent.checkInterfaceSupport(resolver, self.methodName);\n        self.parent.handleCall(promiEvent, resolver.methods[self.methodName], preparedArguments, outputFormatter, callback);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Executes send\n *\n * @param {Object} sendOptions\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.send = function (sendOptions, callback) {\n    var self = this;\n    var promiEvent = new PromiEvent();\n    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);\n    this.parent.registry.getResolver(this.ensName).then(async function (resolver) {\n        await self.parent.checkInterfaceSupport(resolver, self.methodName);\n        self.parent.handleSend(promiEvent, resolver.methods[self.methodName], preparedArguments, sendOptions, callback);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent.eventEmitter;\n};\n/**\n * Handles a call method\n *\n * @param {eventifiedPromise} promiEvent\n * @param {function} method\n * @param {array} preparedArguments\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.handleCall = function (promiEvent, method, preparedArguments, outputFormatter, callback) {\n    method.apply(this, preparedArguments).call()\n        .then(function (result) {\n        if (outputFormatter) {\n            result = outputFormatter(result);\n        }\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency\n            callback(result, result);\n            return;\n        }\n        promiEvent.resolve(result);\n    }).catch(function (error) {\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent;\n};\n/**\n * Handles a send method\n *\n * @param {eventifiedPromise} promiEvent\n * @param {function} method\n * @param {array} preparedArguments\n * @param {Object} sendOptions\n * @param {function} callback\n * @returns {eventifiedPromise}\n */\nResolverMethodHandler.prototype.handleSend = function (promiEvent, method, preparedArguments, sendOptions, callback) {\n    method.apply(this, preparedArguments).send(sendOptions)\n        .on('sending', function () {\n        promiEvent.eventEmitter.emit('sending');\n    })\n        .on('sent', function () {\n        promiEvent.eventEmitter.emit('sent');\n    })\n        .on('transactionHash', function (hash) {\n        promiEvent.eventEmitter.emit('transactionHash', hash);\n    })\n        .on('confirmation', function (confirmationNumber, receipt) {\n        promiEvent.eventEmitter.emit('confirmation', confirmationNumber, receipt);\n    })\n        .on('receipt', function (receipt) {\n        promiEvent.eventEmitter.emit('receipt', receipt);\n        promiEvent.resolve(receipt);\n        if (typeof callback === 'function') {\n            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency\n            callback(receipt, receipt);\n        }\n    })\n        .on('error', function (error) {\n        promiEvent.eventEmitter.emit('error', error);\n        if (typeof callback === 'function') {\n            callback(error, null);\n            return;\n        }\n        promiEvent.reject(error);\n    });\n    return promiEvent;\n};\n/**\n * Adds the ENS node to the arguments\n *\n * @param {string} name\n * @param {array} methodArguments\n *\n * @returns {array}\n */\nResolverMethodHandler.prototype.prepareArguments = function (name, methodArguments) {\n    var node = namehash.hash(name);\n    if (methodArguments.length > 0) {\n        methodArguments.unshift(node);\n        return methodArguments;\n    }\n    return [node];\n};\n/**\n *\n *\n * @param {Contract} resolver\n * @param {string} methodName\n *\n * @returns {Promise}\n */\nResolverMethodHandler.prototype.checkInterfaceSupport = async function (resolver, methodName) {\n    // Skip validation for undocumented interface ids (ex: multihash)\n    if (!interfaceIds[methodName])\n        return;\n    var supported = false;\n    try {\n        supported = await resolver\n            .methods\n            .supportsInterface(interfaceIds[methodName])\n            .call();\n    }\n    catch (err) {\n        console.warn('Could not verify interface of resolver contract at \"' + resolver.options.address + '\". ');\n    }\n    if (!supported) {\n        throw errors.ResolverMethodMissingError(resolver.options.address, methodName);\n    }\n};\nmodule.exports = ResolverMethodHandler;\n\n};"],
"names":["shadow$provide","global","require","module","exports","ResolverMethodHandler","registry","PromiEvent","namehash","errors","interfaceIds","prototype","method","ResolverMethodHandler.prototype.method","ensName","methodName","methodArguments","outputFormatter","callback","call","bind","parent","send","ResolverMethodHandler.prototype.call","self","promiEvent","preparedArguments","prepareArguments","getResolver","then","resolver","checkInterfaceSupport","handleCall","methods","catch","error","reject","eventEmitter","ResolverMethodHandler.prototype.send","sendOptions","handleSend","ResolverMethodHandler.prototype.handleCall","apply","result","resolve","ResolverMethodHandler.prototype.handleSend","on","emit","hash","confirmationNumber","receipt","ResolverMethodHandler.prototype.prepareArguments","name","node","length","unshift","ResolverMethodHandler.prototype.checkInterfaceSupport","supported","supportsInterface","err","console","warn","options","address","ResolverMethodMissingError"]
}
