shadow$provide.module$node_modules$ethereumjs_util$dist_browser$account=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";var __read=this&&this.__read||function(o,n){var m="function"===typeof Symbol&&o[Symbol.iterator];if(!m)return o;o=m.call(o);var r,ar=[];try{for(;(void 0===n||0<n--)&&!(r=o.next()).done;)ar.push(r.value)}catch(error){var e={error}}finally{try{r&&!r.done&&(m=o["return"])&&m.call(o)}finally{if(e)throw e.error;}}return ar};
global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});exports.isZeroAddress=exports.zeroAddress=exports.importPublic=exports.privateToAddress=exports.privateToPublic=exports.publicToAddress=exports.pubToAddress=exports.isValidPublic=exports.isValidPrivate=exports.generateAddress2=exports.generateAddress=exports.isValidChecksumAddress=exports.toChecksumAddress=exports.isValidAddress=exports.Account=void 0;
var assert_1=global(require("module$node_modules$assert$assert")),externals_1=require("module$node_modules$ethereumjs_util$dist_browser$externals"),secp256k1_1=require("module$node_modules$ethereum_cryptography$secp256k1"),internal_1=require("module$node_modules$ethereumjs_util$dist_browser$internal"),constants_1=require("module$node_modules$ethereumjs_util$dist_browser$constants"),bytes_1=require("module$node_modules$ethereumjs_util$dist_browser$bytes"),hash_1=require("module$node_modules$ethereumjs_util$dist_browser$hash"),
helpers_1=require("module$node_modules$ethereumjs_util$dist_browser$helpers"),types_1=require("module$node_modules$ethereumjs_util$dist_browser$types");require=function(){function Account(nonce,balance,stateRoot,codeHash){void 0===nonce&&(nonce=new externals_1.BN(0));void 0===balance&&(balance=new externals_1.BN(0));void 0===stateRoot&&(stateRoot=constants_1.KECCAK256_RLP);void 0===codeHash&&(codeHash=constants_1.KECCAK256_NULL);this.nonce=nonce;this.balance=balance;this.stateRoot=stateRoot;this.codeHash=
codeHash;this._validate()}Account.fromAccountData=function(accountData){var nonce=accountData.nonce,balance=accountData.balance,stateRoot=accountData.stateRoot;accountData=accountData.codeHash;return new Account(nonce?new externals_1.BN((0,bytes_1.toBuffer)(nonce)):void 0,balance?new externals_1.BN((0,bytes_1.toBuffer)(balance)):void 0,stateRoot?(0,bytes_1.toBuffer)(stateRoot):void 0,accountData?(0,bytes_1.toBuffer)(accountData):void 0)};Account.fromRlpSerializedAccount=function(serialized){serialized=
externals_1.rlp.decode(serialized);if(!Array.isArray(serialized))throw Error("Invalid serialized account input. Must be array");return this.fromValuesArray(serialized)};Account.fromValuesArray=function(values){values=__read(values,4);var balance=values[1],stateRoot=values[2],codeHash=values[3];return new Account(new externals_1.BN(values[0]),new externals_1.BN(balance),stateRoot,codeHash)};Account.prototype._validate=function(){if(this.nonce.lt(new externals_1.BN(0)))throw Error("nonce must be greater than zero");
if(this.balance.lt(new externals_1.BN(0)))throw Error("balance must be greater than zero");if(32!==this.stateRoot.length)throw Error("stateRoot must have a length of 32");if(32!==this.codeHash.length)throw Error("codeHash must have a length of 32");};Account.prototype.raw=function(){return[(0,types_1.bnToUnpaddedBuffer)(this.nonce),(0,types_1.bnToUnpaddedBuffer)(this.balance),this.stateRoot,this.codeHash]};Account.prototype.serialize=function(){return externals_1.rlp.encode(this.raw())};Account.prototype.isContract=
function(){return!this.codeHash.equals(constants_1.KECCAK256_NULL)};Account.prototype.isEmpty=function(){return this.balance.isZero()&&this.nonce.isZero()&&this.codeHash.equals(constants_1.KECCAK256_NULL)};return Account}();exports.Account=require;exports.isValidAddress=function(hexAddress){try{(0,helpers_1.assertIsString)(hexAddress)}catch(e){return!1}return/^0x[0-9a-fA-F]{40}$/.test(hexAddress)};exports.toChecksumAddress=function(hexAddress,eip1191ChainId){(0,helpers_1.assertIsHexString)(hexAddress);
hexAddress=(0,internal_1.stripHexPrefix)(hexAddress).toLowerCase();var prefix="";eip1191ChainId&&(prefix=(0,types_1.toType)(eip1191ChainId,types_1.TypeOutput.BN).toString()+"0x");eip1191ChainId=(0,hash_1.keccakFromString)(prefix+hexAddress).toString("hex");prefix="0x";for(var i=0;i<hexAddress.length;i++)prefix=8<=parseInt(eip1191ChainId[i],16)?prefix+hexAddress[i].toUpperCase():prefix+hexAddress[i];return prefix};exports.isValidChecksumAddress=function(hexAddress,eip1191ChainId){return(0,exports.isValidAddress)(hexAddress)&&
(0,exports.toChecksumAddress)(hexAddress,eip1191ChainId)===hexAddress};exports.generateAddress=function(from,nonce){(0,helpers_1.assertIsBuffer)(from);(0,helpers_1.assertIsBuffer)(nonce);nonce=new externals_1.BN(nonce);return nonce.isZero()?(0,hash_1.rlphash)([from,null]).slice(-20):(0,hash_1.rlphash)([from,Buffer.from(nonce.toArray())]).slice(-20)};exports.generateAddress2=function(from,salt,initCode){(0,helpers_1.assertIsBuffer)(from);(0,helpers_1.assertIsBuffer)(salt);(0,helpers_1.assertIsBuffer)(initCode);
(0,assert_1.default)(20===from.length);(0,assert_1.default)(32===salt.length);return(0,hash_1.keccak256)(Buffer.concat([Buffer.from("ff","hex"),from,salt,(0,hash_1.keccak256)(initCode)])).slice(-20)};exports.isValidPrivate=function(privateKey){return(0,secp256k1_1.privateKeyVerify)(privateKey)};exports.isValidPublic=function(publicKey,sanitize){void 0===sanitize&&(sanitize=!1);(0,helpers_1.assertIsBuffer)(publicKey);return 64===publicKey.length?(0,secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]),
publicKey])):sanitize?(0,secp256k1_1.publicKeyVerify)(publicKey):!1};exports.pubToAddress=function(pubKey,sanitize){void 0===sanitize&&(sanitize=!1);(0,helpers_1.assertIsBuffer)(pubKey);sanitize&&64!==pubKey.length&&(pubKey=Buffer.from((0,secp256k1_1.publicKeyConvert)(pubKey,!1).slice(1)));(0,assert_1.default)(64===pubKey.length);return(0,hash_1.keccak)(pubKey).slice(-20)};exports.publicToAddress=exports.pubToAddress;exports.privateToPublic=function(privateKey){(0,helpers_1.assertIsBuffer)(privateKey);
return Buffer.from((0,secp256k1_1.publicKeyCreate)(privateKey,!1)).slice(1)};exports.privateToAddress=function(privateKey){return(0,exports.publicToAddress)((0,exports.privateToPublic)(privateKey))};exports.importPublic=function(publicKey){(0,helpers_1.assertIsBuffer)(publicKey);64!==publicKey.length&&(publicKey=Buffer.from((0,secp256k1_1.publicKeyConvert)(publicKey,!1).slice(1)));return publicKey};exports.zeroAddress=function(){var addr=(0,bytes_1.zeros)(20);return(0,bytes_1.bufferToHex)(addr)};
exports.isZeroAddress=function(hexAddress){try{(0,helpers_1.assertIsString)(hexAddress)}catch(e){return!1}return(0,exports.zeroAddress)()===hexAddress}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist_browser$account.js.map
