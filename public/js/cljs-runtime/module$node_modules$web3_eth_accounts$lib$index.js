shadow$provide.module$node_modules$web3_eth_accounts$lib$index=function(global,require,module,exports){function _validateTransactionForSigning(tx){if(tx.common&&tx.chain&&tx.hardfork)return Error("Please provide the @ethereumjs/common object or the chain and hardfork property but not all together.");if(tx.chain&&!tx.hardfork||tx.hardfork&&!tx.chain)return Error('When specifying chain and hardfork, both values must be defined. Received "chain": '+tx.chain+', "hardfork": '+tx.hardfork);if(!(tx.gas||
tx.gasLimit||tx.maxPriorityFeePerGas||tx.maxFeePerGas))return Error('"gas" is missing');if(tx.gas&&tx.gasPrice){if(0>tx.gas||0>tx.gasPrice)return Error("Gas or gasPrice is lower than 0")}else if(0>tx.maxPriorityFeePerGas||0>tx.maxFeePerGas)return Error("maxPriorityFeePerGas or maxFeePerGas is lower than 0");if(0>tx.nonce||0>tx.chainId)return Error("Nonce or chainId is lower than 0")}function _handleTxType(tx){const hasEip1559=void 0!==tx.maxFeePerGas||void 0!==tx.maxPriorityFeePerGas;let txType;void 0!==
tx.type?txType=utils.toHex(tx.type):void 0===tx.type&&hasEip1559&&(txType="0x2");if(void 0!==tx.gasPrice&&("0x2"===txType||hasEip1559))throw Error("eip-1559 transactions don't support gasPrice");if(("0x1"===txType||"0x0"===txType)&&hasEip1559)throw Error("pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas");if(hasEip1559||tx.common&&tx.common.hardfork&&tx.common.hardfork.toLowerCase()===HardForks.London||tx.hardfork&&tx.hardfork.toLowerCase()===HardForks.London)txType="0x2";
else if(tx.accessList||tx.common&&tx.common.hardfork&&tx.common.hardfork.toLowerCase()===HardForks.Berlin||tx.hardfork&&tx.hardfork.toLowerCase()===HardForks.Berlin)txType="0x1";return txType}function _handleTxPricing(_this,tx){return new Promise((resolve,reject)=>{try{(void 0===tx.type||"0x2">tx.type)&&void 0!==tx.gasPrice?resolve({gasPrice:tx.gasPrice}):Promise.all([_this._ethereumCall.getBlockByNumber(),_this._ethereumCall.getGasPrice()]).then(responses=>{const [block,gasPrice]=responses;if("0x2"===
tx.type&&block&&block.baseFeePerGas){let maxFeePerGas;tx.gasPrice?(maxFeePerGas=responses=tx.gasPrice,delete tx.gasPrice):(responses=tx.maxPriorityFeePerGas||"0x9502F900",maxFeePerGas=tx.maxFeePerGas||utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(responses))));resolve({maxFeePerGas,maxPriorityFeePerGas:responses})}else{if(tx.maxPriorityFeePerGas||tx.maxFeePerGas)throw Error("Network doesn't support eip-1559");resolve({gasPrice})}})}catch(error){reject(error)}})}function Wallet(accounts){this._accounts=
accounts;this.length=0;this.defaultKeyName="web3js_wallet"}var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";var core=require("module$node_modules$web3_core$lib$index"),Method=require("module$node_modules$web3_core_method$lib$index"),Account=require("module$node_modules$eth_lib$lib$account"),cryp=require("module$node_modules$crypto_browserify$index"),scrypt=require("module$node_modules$scrypt_js$scrypt"),uuid=require("module$node_modules$uuid$index"),utils=require("module$node_modules$web3_utils$lib$index"),
helpers=require("module$node_modules$web3_core_helpers$lib$index"),{TransactionFactory}=require("module$node_modules$$ethereumjs$tx$dist_browser$index"),Common=require("module$node_modules$$ethereumjs$common$dist_browser$index").default,HardForks=require("module$node_modules$$ethereumjs$common$dist_browser$index").Hardfork,ethereumjsUtil=require("module$node_modules$ethereumjs_util$dist_browser$index"),isNot=function(value){return"undefined"===typeof value||null===value},isExist=function(value){return"undefined"!==
typeof value&&null!==value};global=function(){var _this=this;core.packageInit(this,arguments);delete this.BatchRequest;delete this.extend;var _ethereumCall=[new Method({name:"getNetworkId",call:"net_version",params:0,outputFormatter:parseInt}),new Method({name:"getChainId",call:"eth_chainId",params:0,outputFormatter:utils.hexToNumber}),new Method({name:"getGasPrice",call:"eth_gasPrice",params:0}),new Method({name:"getTransactionCount",call:"eth_getTransactionCount",params:2,inputFormatter:[function(address){if(utils.isAddress(address))return address;
throw Error("Address "+address+' is not a valid address to get the "transactionCount".');},function(){return"latest"}]}),new Method({name:"getBlockByNumber",call:"eth_getBlockByNumber",params:2,inputFormatter:[function(blockNumber){return blockNumber?utils.toHex(blockNumber):"latest"},function(){return!1}]})];this._ethereumCall={};_ethereumCall.forEach(method=>{method.attachToObject(_this._ethereumCall);method.setRequestManager(_this._requestManager)});this.wallet=new Wallet(this)};global.prototype._addAccountFunctions=
function(account){var _this=this;account.signTransaction=function(tx,callback){return _this.signTransaction(tx,account.privateKey,callback)};account.sign=function(data){return _this.sign(data,account.privateKey)};account.encrypt=function(password,options){return _this.encrypt(account.privateKey,password,options)};return account};global.prototype.create=function(entropy){return this._addAccountFunctions(Account.create(entropy||utils.randomHex(32)))};global.prototype.privateKeyToAccount=function(privateKey,
ignoreLength){privateKey.startsWith("0x")||(privateKey="0x"+privateKey);if(!ignoreLength&&66!==privateKey.length)throw Error("Private key must be 32 bytes long");return this._addAccountFunctions(Account.fromPrivate(privateKey))};global.prototype.signTransaction=function(tx$jscomp$0,privateKey,callback){function signed(tx){const error=_validateTransactionForSigning(tx);if(error)return callback(error),Promise.reject(error);try{var transaction=helpers.formatters.inputCallFormatter(Object.assign({},tx));
transaction.data=transaction.data||"0x";transaction.value=transaction.value||"0x";transaction.gasLimit=transaction.gasLimit||transaction.gas;"0x1"===transaction.type&&void 0===transaction.accessList&&(transaction.accessList=[]);hasTxSigningOptions?(transaction.common&&(transactionOptions.common=Common.forCustomChain(transaction.common.baseChain||"mainnet",{name:transaction.common.customChain.name||"custom-network",networkId:transaction.common.customChain.networkId,chainId:transaction.common.customChain.chainId},
transaction.common.hardfork||HardForks.London),delete transaction.common),transaction.chain&&(transactionOptions.chain=transaction.chain,delete transaction.chain),transaction.hardfork&&(transactionOptions.hardfork=transaction.hardfork,delete transaction.hardfork)):(transactionOptions.common=Common.forCustomChain("mainnet",{name:"custom-network",networkId:transaction.networkId,chainId:transaction.chainId},transaction.hardfork||HardForks.London),delete transaction.networkId);privateKey.startsWith("0x")&&
(privateKey=privateKey.substring(2));var signedTx=TransactionFactory.fromTxData(transaction,transactionOptions).sign(Buffer.from(privateKey,"hex")),validationErrors=signedTx.validate(!0);if(0<validationErrors.length){tx="Signer Error: ";for(const validationError of validationErrors)tx+=`${tx} ${validationError}.`;throw Error(tx);}var rawTransaction="0x"+signedTx.serialize().toString("hex"),transactionHash=utils.keccak256(rawTransaction),result={messageHash:"0x"+Buffer.from(signedTx.getMessageToSign(!0)).toString("hex"),
v:"0x"+signedTx.v.toString("hex"),r:"0x"+signedTx.r.toString("hex"),s:"0x"+signedTx.s.toString("hex"),rawTransaction,transactionHash};callback(null,result);return result}catch(e){return callback(e),Promise.reject(e)}}var error$jscomp$0=!1,transactionOptions={},hasTxSigningOptions=!(!tx$jscomp$0||!(tx$jscomp$0.chain&&tx$jscomp$0.hardfork||tx$jscomp$0.common));callback=callback||function(){};if(!tx$jscomp$0)return error$jscomp$0=Error("No transaction object given!"),callback(error$jscomp$0),Promise.reject(error$jscomp$0);
if(isExist(tx$jscomp$0.common)&&isNot(tx$jscomp$0.common.customChain))return error$jscomp$0=Error("If tx.common is provided it must have tx.common.customChain"),callback(error$jscomp$0),Promise.reject(error$jscomp$0);if(isExist(tx$jscomp$0.common)&&isNot(tx$jscomp$0.common.customChain.chainId))return error$jscomp$0=Error("If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId"),callback(error$jscomp$0),Promise.reject(error$jscomp$0);if(isExist(tx$jscomp$0.common)&&
isExist(tx$jscomp$0.common.customChain.chainId)&&isExist(tx$jscomp$0.chainId)&&tx$jscomp$0.chainId!==tx$jscomp$0.common.customChain.chainId)return error$jscomp$0=Error("Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"),callback(error$jscomp$0),Promise.reject(error$jscomp$0);tx$jscomp$0.type=_handleTxType(tx$jscomp$0);return void 0!==tx$jscomp$0.nonce&&void 0!==tx$jscomp$0.chainId&&(void 0!==tx$jscomp$0.gasPrice||void 0!==tx$jscomp$0.maxFeePerGas&&void 0!==tx$jscomp$0.maxPriorityFeePerGas)&&
hasTxSigningOptions?Promise.resolve(signed(tx$jscomp$0)):Promise.all([isNot(tx$jscomp$0.common)||isNot(tx$jscomp$0.common.customChain.chainId)?isNot(tx$jscomp$0.chainId)?this._ethereumCall.getChainId():tx$jscomp$0.chainId:void 0,isNot(tx$jscomp$0.nonce)?this._ethereumCall.getTransactionCount(this.privateKeyToAccount(privateKey).address):tx$jscomp$0.nonce,isNot(hasTxSigningOptions)?this._ethereumCall.getNetworkId():1,_handleTxPricing(this,tx$jscomp$0)]).then(function(args){const [txchainId,txnonce,
txnetworkId,txgasInfo]=args;if(isNot(txchainId)&&isNot(tx$jscomp$0.common)&&isNot(tx$jscomp$0.common.customChain.chainId)||isNot(txnonce)||isNot(txnetworkId)||isNot(txgasInfo))throw Error('One of the values "chainId", "networkId", "gasPrice", or "nonce" couldn\'t be fetched: '+JSON.stringify(args));return signed({...tx$jscomp$0,...(isNot(tx$jscomp$0.common)||isNot(tx$jscomp$0.common.customChain.chainId)?{chainId:txchainId}:{}),nonce:txnonce,networkId:txnetworkId,...txgasInfo})})};global.prototype.recoverTransaction=
function(rawTx,txOptions){rawTx=Buffer.from(rawTx.slice(2),"hex");rawTx=TransactionFactory.fromSerializedData(rawTx);return utils.toChecksumAddress(rawTx.getSenderAddress().toString("hex"))};global.prototype.hashMessage=function(data){data=utils.isHexStrict(data)?data:utils.utf8ToHex(data);var messageBytes=utils.hexToBytes(data);data=Buffer.from(messageBytes);messageBytes=Buffer.from("Ethereum Signed Message:\n"+messageBytes.length);data=Buffer.concat([messageBytes,data]);return ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(data))};
global.prototype.sign=function(data,privateKey){privateKey.startsWith("0x")||(privateKey="0x"+privateKey);if(66!==privateKey.length)throw Error("Private key must be 32 bytes long");var hash=this.hashMessage(data);privateKey=Account.sign(hash,privateKey);var vrs=Account.decodeSignature(privateKey);return{message:data,messageHash:hash,v:vrs[0],r:vrs[1],s:vrs[2],signature:privateKey}};global.prototype.recover=function(message,signature,preFixed){var args=[].slice.apply(arguments);if(message&&"object"===
typeof message)return this.recover(message.messageHash,Account.encodeSignature([message.v,message.r,message.s]),!0);preFixed||(message=this.hashMessage(message));return 4<=args.length?(preFixed=args.slice(-1)[0],preFixed="boolean"===typeof preFixed?!!preFixed:!1,this.recover(message,Account.encodeSignature(args.slice(1,4)),preFixed)):Account.recover(message,signature)};global.prototype.decrypt=function(v3Keystore,password,nonStrict){if("string"!==typeof password)throw Error("No password given.");
v3Keystore=v3Keystore&&"object"===typeof v3Keystore?v3Keystore:JSON.parse(nonStrict?v3Keystore.toLowerCase():v3Keystore);if(3!==v3Keystore.version)throw Error("Not a valid V3 wallet");if("scrypt"===v3Keystore.crypto.kdf)nonStrict=v3Keystore.crypto.kdfparams,nonStrict=scrypt.syncScrypt(Buffer.from(password),Buffer.from(nonStrict.salt,"hex"),nonStrict.n,nonStrict.r,nonStrict.p,nonStrict.dklen);else if("pbkdf2"===v3Keystore.crypto.kdf){nonStrict=v3Keystore.crypto.kdfparams;if("hmac-sha256"!==nonStrict.prf)throw Error("Unsupported parameters to PBKDF2");
nonStrict=cryp.pbkdf2Sync(Buffer.from(password),Buffer.from(nonStrict.salt,"hex"),nonStrict.c,nonStrict.dklen,"sha256")}else throw Error("Unsupported key derivation scheme");password=Buffer.from(v3Keystore.crypto.ciphertext,"hex");if(utils.sha3(Buffer.from([...nonStrict.slice(16,32),...password])).replace("0x","")!==v3Keystore.crypto.mac)throw Error("Key derivation failed - possibly wrong password");v3Keystore=cryp.createDecipheriv(v3Keystore.crypto.cipher,nonStrict.slice(0,16),Buffer.from(v3Keystore.crypto.cipherparams.iv,
"hex"));password="0x"+Buffer.from([...v3Keystore.update(password),...v3Keystore.final()]).toString("hex");return this.privateKeyToAccount(password,!0)};global.prototype.encrypt=function(privateKey,password,options){privateKey=this.privateKeyToAccount(privateKey,!0);options=options||{};var salt=options.salt||cryp.randomBytes(32),iv=options.iv||cryp.randomBytes(16),kdf=options.kdf||"scrypt";salt={dklen:options.dklen||32,salt:salt.toString("hex")};if("pbkdf2"===kdf)salt.c=options.c||262144,salt.prf=
"hmac-sha256",password=cryp.pbkdf2Sync(Buffer.from(password),Buffer.from(salt.salt,"hex"),salt.c,salt.dklen,"sha256");else if("scrypt"===kdf)salt.n=options.n||8192,salt.r=options.r||8,salt.p=options.p||1,password=scrypt.syncScrypt(Buffer.from(password),Buffer.from(salt.salt,"hex"),salt.n,salt.r,salt.p,salt.dklen);else throw Error("Unsupported kdf");var cipher=cryp.createCipheriv(options.cipher||"aes-128-ctr",password.slice(0,16),iv);if(!cipher)throw Error("Unsupported cipher");cipher=Buffer.from([...cipher.update(Buffer.from(privateKey.privateKey.replace("0x",
""),"hex")),...cipher.final()]);password=utils.sha3(Buffer.from([...password.slice(16,32),...cipher])).replace("0x","");return{version:3,id:uuid.v4({random:options.uuid||cryp.randomBytes(16)}),address:privateKey.address.toLowerCase().replace("0x",""),crypto:{ciphertext:cipher.toString("hex"),cipherparams:{iv:iv.toString("hex")},cipher:options.cipher||"aes-128-ctr",kdf,kdfparams:salt,mac:password.toString("hex")}}};Wallet.prototype._findSafeIndex=function(pointer){pointer=pointer||0;return this.hasOwnProperty(pointer)?
this._findSafeIndex(pointer+1):pointer};Wallet.prototype._currentIndexes=function(){return Object.keys(this).map(function(key){return parseInt(key)}).filter(function(n){return 9E20>n})};Wallet.prototype.create=function(numberOfAccounts,entropy){for(var i=0;i<numberOfAccounts;++i)this.add(this._accounts.create(entropy).privateKey);return this};Wallet.prototype.add=function(account){"string"===typeof account&&(account=this._accounts.privateKeyToAccount(account));if(this[account.address])return this[account.address];
account=this._accounts.privateKeyToAccount(account.privateKey);account.index=this._findSafeIndex();this[account.index]=account;this[account.address]=account;this[account.address.toLowerCase()]=account;this.length++;return account};Wallet.prototype.remove=function(addressOrIndex){return(addressOrIndex=this[addressOrIndex])&&addressOrIndex.address?(this[addressOrIndex.address].privateKey=null,delete this[addressOrIndex.address],this[addressOrIndex.address.toLowerCase()].privateKey=null,delete this[addressOrIndex.address.toLowerCase()],
this[addressOrIndex.index].privateKey=null,delete this[addressOrIndex.index],this.length--,!0):!1};Wallet.prototype.clear=function(){var _this=this;this._currentIndexes().forEach(function(index){_this.remove(index)});return this};Wallet.prototype.encrypt=function(password,options){var _this=this;return this._currentIndexes().map(function(index){return _this[index].encrypt(password,options)})};Wallet.prototype.decrypt=function(encryptedWallet,password){var _this=this;encryptedWallet.forEach(function(keystore){if(keystore=
_this._accounts.decrypt(keystore,password))_this.add(keystore);else throw Error("Couldn't decrypt accounts. Password wrong?");});return this};Wallet.prototype.save=function(password,keyName){localStorage.setItem(keyName||this.defaultKeyName,JSON.stringify(this.encrypt(password)));return!0};Wallet.prototype.load=function(password,keyName){if(keyName=localStorage.getItem(keyName||this.defaultKeyName))try{keyName=JSON.parse(keyName)}catch(e){}return this.decrypt(keyName||[],password)};(function(type){try{var storage=
window[type];storage.setItem("__storage_test__","__storage_test__");storage.removeItem("__storage_test__");return!0}catch(e){return e&&(22===e.code||1014===e.code||"QuotaExceededError"===e.name||"NS_ERROR_DOM_QUOTA_REACHED"===e.name)&&storage&&0!==storage.length}})("localStorage")||(delete Wallet.prototype.save,delete Wallet.prototype.load);module.exports=global}
//# sourceMappingURL=module$node_modules$web3_eth_accounts$lib$index.js.map
