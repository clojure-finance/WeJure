shadow$provide.module$node_modules$keccak$lib$api$shake=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;const {Transform}=require("module$node_modules$keccak$node_modules$readable_stream$readable_browser");module.exports=KeccakState=>class Shake extends Transform{constructor(rate,capacity,delimitedSuffix,options){super(options);this._rate=rate;this._capacity=capacity;this._delimitedSuffix=delimitedSuffix;this._options=options;this._state=new KeccakState;
this._state.initialize(rate,capacity);this._finalized=!1}_transform(chunk,encoding,callback){let error=null;try{this.update(chunk,encoding)}catch(err){error=err}callback(error)}_flush(){}_read(size){this.push(this.squeeze(size))}update(data,encoding){if(!Buffer.isBuffer(data)&&"string"!==typeof data)throw new TypeError("Data must be a string or a buffer");if(this._finalized)throw Error("Squeeze already called");Buffer.isBuffer(data)||(data=Buffer.from(data,encoding));this._state.absorb(data);return this}squeeze(dataByteLength,
encoding){this._finalized||(this._finalized=!0,this._state.absorbLastFewBits(this._delimitedSuffix));dataByteLength=this._state.squeeze(dataByteLength);void 0!==encoding&&(dataByteLength=dataByteLength.toString(encoding));return dataByteLength}_resetState(){this._state.initialize(this._rate,this._capacity);return this}_clone(){const clone=new Shake(this._rate,this._capacity,this._delimitedSuffix,this._options);this._state.copy(clone._state);clone._finalized=this._finalized;return clone}}}
//# sourceMappingURL=module$node_modules$keccak$lib$api$shake.js.map
