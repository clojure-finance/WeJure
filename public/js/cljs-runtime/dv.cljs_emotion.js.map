{"version":3,"sources":["dv/cljs_emotion.cljc"],"mappings":"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","names":["dv.cljs-emotion/emotion-hash","goog.object/get","js/module$node_modules$$emotion$hash$dist$hash_browser_cjs","dv.cljs-emotion/styled","js/module$node_modules$$emotion$styled$dist$emotion_styled_browser_cjs","dv.cljs-emotion/jsx","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.jsx","dv.cljs-emotion/obj-set","o","k","v","goog.object/set","dv.cljs-emotion/obj-get","dv.cljs-emotion/force-children","x","cljs.core/seq?","cljs.core/to-array","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","dv.cljs-emotion/kebab->camel","prop","clojure.string/starts-with?","clojure.string/includes?","words","cljs.core/re-seq","clojure.string/capitalize","cljs.core.update.cljs$core$IFn$_invoke$arity$3","clojure.string/lower-case","clojure.string.join.cljs$core$IFn$_invoke$arity$1","dv.cljs-emotion/camelize-keys","style-map","clojure.walk/postwalk","cljs.core/Keyword","cljs.core/name","and__4120__auto__","cljs.core/meta","cljs.core/contains?","dv.cljs-emotion/keyframes","anim-map","G__21691","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.keyframes","cljs.core/clj->js","dv.cljs-emotion/cljs-props-key","goog/define","dv.cljs-emotion/add-class-names?","cljs.core/boolean?","dv.cljs-emotion/ADD_CLASSNAMES","js/goog.DEBUG","dv.cljs-emotion/add-class-name","props","class-name","cljs.core/object?","G__21696","G__21697","G__21698","G__21699","clojure.string.join.cljs$core$IFn$_invoke$arity$2","clojure.string/trim","p1__21695#","dv.cljs-emotion/hashit","string","dv.cljs-emotion/set-class-name","hashed-name","dv.cljs-emotion/map->obj","m","cljs.core/reduce-kv","new-k","G__21700","cljs.core/PROTOCOL_SENTINEL","new-v","G__21702","cljs.core/map?","G__21703","dv.cljs-emotion/make-js-props","clj-props","js-props","G__21704","dv.cljs-emotion/react-factory","el","G__21705","G__21706","js/module$node_modules$react$index.createElement","e21707","or__4131__auto__","js/module$node_modules$react$index.isValidElement","G__21708","G__21709","G__21710","G__21711","G__21712","G__21713","G__21714","cljs.core/array?","cljs.core/coll?","G__21715","G__21716","G__21717","G__21718","G__21719","js/Object","e","js/console.error","children","cljs.core/not","cljs.core/seq","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2","dv.cljs-emotion/global*","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.Global","dv.cljs-emotion/global-style","G__21721","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","dv.cljs-emotion/theme-provider","seq21722","G__21723","cljs.core/first","cljs.core/next","self__4717__auto__","js/Error","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.ThemeProvider"],"sourcesContent":["(ns dv.cljs-emotion\n  (:require\n    #?@(:cljs [[\"react\" :as react]\n               [\"@emotion/hash\" :as emotion-hash*]\n               [\"@emotion/styled\" :as styled*]\n               [\"@emotion/react\" :as styled-core :refer [Global ThemeProvider]]\n               [goog.object :as g]])\n    [clojure.string :as str]\n    [clojure.walk :as walk]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]])\n  #?(:cljs (:require-macros [dv.cljs-emotion :refer [defstyled css]])))\n\n;; Support plain cljs compiler and shadow.\n#?(:cljs (def emotion-hash (g/get emotion-hash* \"default\")))\n#?(:cljs (def styled (g/get styled* \"default\")))\n#?(:cljs (def jsx styled-core/jsx))\n\n;; Used to prevent generated code from needing to require goog.object\n(defn obj-set [o k v]\n  #?(:cljs (g/set o k v)\n     :clj  nil))\n\n(defn obj-get [o k]\n  #?(:cljs (g/get o k)\n     :clj  nil))\n\n;; from fulcro\n#?(:cljs\n   (defn force-children\n     \"Utility function that will force a lazy sequence of children (recursively) into realized\n     vectors (React cannot deal with lazy seqs in production mode)\"\n     [x]\n     (if (seq? x)\n       (to-array (mapv force-children x))\n       x)))\n\n#?(:cljs\n   (>defn kebab->camel\n     [prop]\n     [string? => string?]\n     (if (str/starts-with? prop \".\")\n       prop\n\n       (if (str/includes? prop \"-\")\n         (let [words (->> (re-seq #\"[a-zA-Z]+\" prop)\n                       (mapv str/capitalize))]\n           (-> words\n             (update 0 str/lower-case)\n             str/join))\n         prop))))\n\n;; todo use the caching strategy seen in reagent.impl.template\n\n#?(:cljs\n   (defn camelize-keys\n     \"Also replaces styled components with their css classname is key position.\"\n     [style-map]\n     (walk/postwalk\n       (fn in-walk [v]\n         (cond\n           (keyword? v)\n           (-> v name kebab->camel)\n\n           (and (meta v) (contains? (meta v) ::hashed-name))\n           (str \".\" (-> v meta ::hashed-name))\n\n           :else v))\n       style-map)))\n\n#?(:cljs\n   (defn keyframes [anim-map]\n     (styled-core/keyframes (clj->js (camelize-keys anim-map)))))\n\n(def cljs-props-key \"dv.cljs-emotion/props\")\n\n#?(:clj\n   (defn wrap-call-style-fn [anon-styles?]\n     `(fn [x#]\n        (cond\n\n          ;; Another emotion styled component created with this lib.\n          (and (meta x#) (contains? (meta x#) ::hashed-name))\n          (str \".\" (-> x# meta ::hashed-name))\n\n          (cljs.core/fn? x#)\n          (cljs.core/fn [arg#]\n            ;; arg# is js props passed at runtime, we ship it back and forth js -> cljs -> js\n\n            ;; js->clj is resulting in an infinite recur when children contains another styled component, so we remove it.\n            (cljs.core/js-delete arg# \"children\")\n\n            (if ~anon-styles?\n              ;; with anonymous styles there can be no props - so the theme is passed as the only argument\n              (cljs.core/clj->js (camelize-keys (x# (cljs.core/js->clj arg# :keywordize-keys true))))\n              (let [cljs-args# (assoc (obj-get arg# ~cljs-props-key)\n                                 :theme (cljs.core/js->clj (obj-get arg# \"theme\") :keywordize-keys true))]\n                ;; invoke the user-supplied function which returns style data - convert whatever they return to js data structures.\n                (cljs.core/clj->js (camelize-keys (x# cljs-args#))))))\n\n          ;; maps come up in value position for nested selectors\n          (map? x#)\n          (camelize-keys (cljs.core/js->clj x# :keywordize-keys true))\n\n          :else x#))))\n\n#?(:cljs (goog-define ADD_CLASSNAMES \"INITIAL\"))\n\n#?(:cljs\n   (defn add-class-names? []\n     (if (boolean? ADD_CLASSNAMES)\n       ADD_CLASSNAMES\n       goog.DEBUG)))\n\n#?(:cljs\n   (defn add-class-name [props class-name]\n     (if (object? props)\n       (doto props\n         (goog.object/set \"className\"\n           (->> [class-name (goog.object/get props \"className\")]\n             (str/join \" \")\n             (str/trim))))\n       (update props :className #(if (nil? %) class-name (str class-name \" \" %))))))\n\n#?(:cljs (defn hashit [string] (str \"dvcss-\" (emotion-hash string))))\n\n#?(:cljs\n   (defn set-class-name [props class-name]\n     (if class-name\n       (let [hashed-name (hashit class-name)\n             props       (add-class-name props hashed-name)]\n         (if (add-class-names?)\n           (add-class-name props class-name)\n           props))\n       props)))\n\n#?(:cljs\n   (defn map->obj [m]\n     (reduce-kv (fn [o k v]\n                  ;; convert keywords to string only in key position\n                  (let [new-k (cond-> k (implements? INamed k) name)\n                        new-v (cond-> v (map? v) map->obj)]\n                    (doto o (obj-set new-k new-v))))\n       #js{} m)))\n\n#?(:cljs\n   (defn make-js-props [props class-name]\n     (if (object? props)\n       props\n       (let [clj-props (set-class-name props class-name)\n             js-props  (map->obj clj-props)]\n         (doto js-props (obj-set cljs-props-key clj-props))))))\n\n#?(:cljs\n   (defn react-factory [el class-name]\n     (fn\n       ([]\n        (react/createElement el (clj->js (set-class-name {} class-name))))\n       ([props]\n        (try\n          (cond\n            (or (react/isValidElement props) (string? props))\n            (react/createElement el (set-class-name #js{} class-name) props)\n\n            (map? props)\n            ;; Do not use clj->js in order to preserve clojure data types like keywords that would not\n            ;; survive a round-trip clj->js js->clj\n            (react/createElement el (make-js-props props class-name))\n\n            (object? props)\n            (react/createElement el (set-class-name props class-name))\n\n            (or (array? props) (coll? props))\n            (react/createElement el (set-class-name #js{} class-name) (force-children props))\n\n            :else\n            (react/createElement el (set-class-name #js{} class-name)))\n\n          (catch js/Object e\n            (js/console.error \"Error invoking an emotion styled component: \" e))))\n\n       ([props & children]\n        ;; if props are a mapping type and not a react child\n        (if (or (and (object? props) (not (react/isValidElement props))) (map? props))\n          (let [js-props (make-js-props props class-name)]\n            (if (seq children)\n              (apply react/createElement el js-props (force-children children))\n              (react/createElement el js-props)))\n          (apply react/createElement el (set-class-name #js{} class-name) (force-children (list* props children))))))))\n\n#?(:clj\n   (defn get-type\n     [styled-arg tag-name]\n     (cond\n       ;; if literals, don't need to determine type at runtime\n       ;; a dom element like :div, same as styled.div``\n       (string? tag-name) `(obj-get ~styled-arg ~tag-name)\n       (keyword? tag-name) `(obj-get ~styled-arg ~(name tag-name))\n       :else\n       `(cond\n          (string? ~tag-name)\n          (obj-get ~styled-arg ~tag-name)\n\n          (keyword? ~tag-name)\n          (obj-get ~styled-arg ~(name tag-name))\n\n          ;; Another styled component\n          (::styled (meta ~tag-name))\n          (.call ~styled-arg ~styled-arg (::styled (meta ~tag-name)))\n\n          ;; A React component\n          :else\n          (.call ~styled-arg ~styled-arg ~tag-name)))))\n\n#?(:clj\n   (defn get-cls-name\n     [namespace-name print-style component-sym]\n     (case print-style\n       :full (str namespace-name \"/\" component-sym)\n       :short (str component-sym)\n       :nil nil)))\n\n#?(:clj (def default-classname-style :full))\n\n#?(:clj\n   (defn get-cls-name-from-meta\n     \"Returns string or nil for the classname\"\n     [namespace-name component-sym]\n     (if (contains? (meta component-sym) :styled/classname)\n       (let [print-config (:styled/classname (meta component-sym))]\n         (if (#{:full :short :nil} print-config)\n           (get-cls-name namespace-name print-config component-sym)\n           (throw (Exception. (str \"Unknown option for class-name style in metadata passed to component: \" component-sym)))))\n       (get-cls-name namespace-name default-classname-style component-sym))))\n\n#?(:clj\n   (defmacro defstyled\n     ([component-name el & children]\n      (let [component-type  (gensym \"component-type\")\n            clss            (gensym \"clss\")\n            class-name      (gensym \"className\")\n            full-class-name (gensym \"fullClassName\")\n            children*       (gensym \"children\")]\n        `(let [~class-name ~(get-cls-name-from-meta (-> &env :ns :name) component-name)\n               ~full-class-name ~(str (-> &env :ns :name) \"/\" component-name)\n\n               ~children*\n               (walk/postwalk\n                 ;; todo here you can do props validation also\n                 ;; should not allow anything that's not a symbol, map, vector, js-obj, js-array, fn\n                 ~(wrap-call-style-fn false)\n                 ~(vec children))\n\n               ;; pass js structures to the lib\n               ~children* (cljs.core/clj->js ~children*)\n               ~component-type ~(get-type `styled el)\n               ~clss (.apply ~component-type ~component-type ~children*)]\n           (obj-set ~clss \"displayName\" ~(str (-> &env :ns :name) \"/\" component-name))\n\n           (def ~component-name\n             (with-meta (react-factory ~clss ~class-name)\n               {::styled      ~clss\n                ::hashed-name (hashit ~full-class-name)}))\n           (cljs.core/specify! ~component-name\n             ;~'IPrintWithWriter\n             ;(~'-pr-writer [this# writer# _#]\n             ;  (~'-write writer# (cljs.core/str this#)))\n             ~'Object\n             (~'toString [this#]\n               (cljs.core/str \".\" (::hashed-name (meta ~component-name))))))))))\n\n#?(:clj\n   (comment\n     (macroexpand-1 '(defstyled button4 button3 {:fontSize \"20em\"}))\n     (macroexpand '(defstyled button3 :button\n                     {:background \"lightblue\" :color \"green\"}))\n\n     (macroexpand-1\n       '(defstyled button3 :button\n          {:background \"lightblue\"\n           button1     {:color \"green\"}}\n          (fn [jsprops cp]\n            {:color (or (:color cp) \"white\")})))\n\n     ;; postwalk doesn't continue expanding replaced values, like the fn call here:\n     (walk/postwalk\n       (fn [i]\n         (cond\n           (fn? i) (i)\n           (keyword? i) (kebab->camel (name i))\n           :else i))\n       [{:background-color \"blue\"}\n        (fn [] {:border-radius 5})])))\n\n(comment\n  (camelize-keys\n    [{:background    \"lightblue\"\n      :font-size     20\n      :border-radius \"10px\"}\n     {:background-image \"url(xyz.com/my-image)\"}])\n  (camelize-keys\n    {:background                \"lightblue\"\n     :font-size                 20\n     \"@media(min-width: 200px)\" {:font-size 33}\n     :border-radius             \"10px\"})\n\n  (walk/postwalk\n    (fn [item]\n      (println \"item: \" item \" map entry: \" (map-entry? item) \" vec? \" (vector? item))\n      (cond\n        (keyword? item)\n        (do\n          (println \"found keyword\")\n          (keyword (kebab->camel (name item))))\n        :elseeeee item)\n      )\n    {:background    \"lightblue\"\n     :font-size     20\n     \"@media(min-width: 200px)\"\n     [{:font-size 33}\n      {:background-color \"purple\"}]\n     :border-radius \"10px\"}))\n\n#?(:cljs\n   (def ^:private global* (react-factory Global nil)))\n\n;; emotion doesn't allow functions in nested position, only\n;; objects and arrays of objects\n;; but they do allow one function as a child\n;; you can always wrap the call in a fn if you want dynamism like below\n;https://github.com/emotion-js/emotion/blob/188dc0e785cfc9b10b3f9a6ead62b56ddd38e039/packages/core/src/global.js#L16\n\n#?(:cljs\n   (defn global-style [props]\n     (global* {:styles (camelize-keys props)})))\n\n;; can use like so:\n(comment\n  (global-style {:body {:background \"#cce\" \"@media (min-width:700px)\" {:background \"white\"}}})\n  (global-style\n    [(clj->js {:body {:font-family \"serif\"}}) {:body {:border \"2px solid yellOW\"}} {:body {:background-color \"#ecccee\"}}])\n\n  ;; to adapt based on props, wrap in a fn:\n  (defn my-globals [props]\n    (global-style\n      {:body {:background-color \"red\"}}))\n  )\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Theme support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:cljs\n   (defn theme-provider\n     [props & children]\n     (when-not (contains? props :theme)\n       (throw (js/Error. \"You must pass a :theme to the theme-provider.\")))\n     (apply react/createElement ThemeProvider\n       (clj->js props)\n       (force-children children))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; CSS prop support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (defn css-body [props]\n     `(do\n        (assert (contains? ~props :css) \"Props must contain :css key\")\n        (cljs.core/clj->js\n          (assoc ~props :css\n                        (walk/postwalk\n                          ;; todo here you can do props validation also\n                          ;; should not allow anything that's not a symbol, map, vector, js-obj, js-array, fn\n                          ~(wrap-call-style-fn true)\n                          (:css ~props)))))))\n#?(:clj\n   (defmacro css\n     ([el props]\n      (let [el        (cond-> el (keyword? el) name)\n            css-props (css-body props)]\n        `(jsx ~el ~css-props)))\n\n     ([el props children]\n      (let [el        (cond-> el (keyword? el) name)\n            css-props (css-body props)]\n        `(jsx ~el ~css-props ~children)))))\n"]}