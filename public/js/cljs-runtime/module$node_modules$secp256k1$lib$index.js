shadow$provide.module$node_modules$secp256k1$lib$index=function(global,require,module,exports){function assert(cond,msg){if(!cond)throw Error(msg);}function isUint8Array(name,value,length){assert(value instanceof Uint8Array,`Expected ${name} to be an Uint8Array`);if(void 0!==length)if(Array.isArray(length)){const numbers=length.join(", ");name=`Expected ${name} to be an Uint8Array with length [${numbers}]`;assert(length.includes(value.length),name)}else assert(value.length===length,`Expected ${name} to be an Uint8Array with length ${length}`)}
function isCompressed(value){assert("Boolean"===toTypeString(value),"Expected compressed to be a Boolean")}function getAssertedOutput(output=len=>new Uint8Array(len),length){"function"===typeof output&&(output=output(length));isUint8Array("output",output,length);return output}function toTypeString(value){return Object.prototype.toString.call(value).slice(8,-1)}module.exports=secp256k1=>({contextRandomize(seed){assert(null===seed||seed instanceof Uint8Array,"Expected seed to be an Uint8Array or null");
null!==seed&&isUint8Array("seed",seed,32);switch(secp256k1.contextRandomize(seed)){case 1:throw Error("Unknow error on context randomization");}},privateKeyVerify(seckey){isUint8Array("private key",seckey,32);return 0===secp256k1.privateKeyVerify(seckey)},privateKeyNegate(seckey){isUint8Array("private key",seckey,32);switch(secp256k1.privateKeyNegate(seckey)){case 0:return seckey;case 1:throw Error("Impossible case. Please create issue.");}},privateKeyTweakAdd(seckey,tweak){isUint8Array("private key",
seckey,32);isUint8Array("tweak",tweak,32);switch(secp256k1.privateKeyTweakAdd(seckey,tweak)){case 0:return seckey;case 1:throw Error("The tweak was out of range or the resulted private key is invalid");}},privateKeyTweakMul(seckey,tweak){isUint8Array("private key",seckey,32);isUint8Array("tweak",tweak,32);switch(secp256k1.privateKeyTweakMul(seckey,tweak)){case 0:return seckey;case 1:throw Error("The tweak was out of range or equal to zero");}},publicKeyVerify(pubkey){isUint8Array("public key",pubkey,
[33,65]);return 0===secp256k1.publicKeyVerify(pubkey)},publicKeyCreate(seckey,compressed=!0,output){isUint8Array("private key",seckey,32);isCompressed(compressed);output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyCreate(output,seckey)){case 0:return output;case 1:throw Error("Private Key is invalid");case 2:throw Error("Public Key serialization error");}},publicKeyConvert(pubkey,compressed=!0,output){isUint8Array("public key",pubkey,[33,65]);isCompressed(compressed);output=
getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyConvert(output,pubkey)){case 0:return output;case 1:throw Error("Public Key could not be parsed");case 2:throw Error("Public Key serialization error");}},publicKeyNegate(pubkey,compressed=!0,output){isUint8Array("public key",pubkey,[33,65]);isCompressed(compressed);output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyNegate(output,pubkey)){case 0:return output;case 1:throw Error("Public Key could not be parsed");
case 2:throw Error("Impossible case. Please create issue.");case 3:throw Error("Public Key serialization error");}},publicKeyCombine(pubkeys,compressed=!0,output){assert(Array.isArray(pubkeys),"Expected public keys to be an Array");assert(0<pubkeys.length,"Expected public keys array will have more than zero items");for(const pubkey of pubkeys)isUint8Array("public key",pubkey,[33,65]);isCompressed(compressed);output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyCombine(output,
pubkeys)){case 0:return output;case 1:throw Error("Public Key could not be parsed");case 2:throw Error("The sum of the public keys is not valid");case 3:throw Error("Public Key serialization error");}},publicKeyTweakAdd(pubkey,tweak,compressed=!0,output){isUint8Array("public key",pubkey,[33,65]);isUint8Array("tweak",tweak,32);isCompressed(compressed);output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyTweakAdd(output,pubkey,tweak)){case 0:return output;case 1:throw Error("Public Key could not be parsed");
case 2:throw Error("The tweak was out of range or the resulted private key is invalid");}},publicKeyTweakMul(pubkey,tweak,compressed=!0,output){isUint8Array("public key",pubkey,[33,65]);isUint8Array("tweak",tweak,32);isCompressed(compressed);output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.publicKeyTweakMul(output,pubkey,tweak)){case 0:return output;case 1:throw Error("Public Key could not be parsed");case 2:throw Error("The tweak was out of range or equal to zero");}},signatureNormalize(sig){isUint8Array("signature",
sig,64);switch(secp256k1.signatureNormalize(sig)){case 0:return sig;case 1:throw Error("Signature could not be parsed");}},signatureExport(sig,output){isUint8Array("signature",sig,64);output=getAssertedOutput(output,72);const obj={output,outputlen:72};switch(secp256k1.signatureExport(obj,sig)){case 0:return output.slice(0,obj.outputlen);case 1:throw Error("Signature could not be parsed");case 2:throw Error("Impossible case. Please create issue.");}},signatureImport(sig,output){isUint8Array("signature",
sig);output=getAssertedOutput(output,64);switch(secp256k1.signatureImport(output,sig)){case 0:return output;case 1:throw Error("Signature could not be parsed");case 2:throw Error("Impossible case. Please create issue.");}},ecdsaSign(msg32,seckey,options={},output){isUint8Array("message",msg32,32);isUint8Array("private key",seckey,32);assert("Object"===toTypeString(options),"Expected options to be an Object");void 0!==options.data&&isUint8Array("options.data",options.data);void 0!==options.noncefn&&
assert("Function"===toTypeString(options.noncefn),"Expected options.noncefn to be a Function");output=getAssertedOutput(output,64);output={signature:output,recid:null};switch(secp256k1.ecdsaSign(output,msg32,seckey,options.data,options.noncefn)){case 0:return output;case 1:throw Error("The nonce generation function failed, or the private key was invalid");case 2:throw Error("Impossible case. Please create issue.");}},ecdsaVerify(sig,msg32,pubkey){isUint8Array("signature",sig,64);isUint8Array("message",
msg32,32);isUint8Array("public key",pubkey,[33,65]);switch(secp256k1.ecdsaVerify(sig,msg32,pubkey)){case 0:return!0;case 3:return!1;case 1:throw Error("Signature could not be parsed");case 2:throw Error("Public Key could not be parsed");}},ecdsaRecover(sig,recid,msg32,compressed=!0,output){isUint8Array("signature",sig,64);assert("Number"===toTypeString(recid)&&0<=recid&&3>=recid,"Expected recovery id to be a Number within interval [0, 3]");isUint8Array("message",msg32,32);isCompressed(compressed);
output=getAssertedOutput(output,compressed?33:65);switch(secp256k1.ecdsaRecover(output,sig,recid,msg32)){case 0:return output;case 1:throw Error("Signature could not be parsed");case 2:throw Error("Public key could not be recover");case 3:throw Error("Impossible case. Please create issue.");}},ecdh(pubkey,seckey,options={},output){isUint8Array("public key",pubkey,[33,65]);isUint8Array("private key",seckey,32);assert("Object"===toTypeString(options),"Expected options to be an Object");void 0!==options.data&&
isUint8Array("options.data",options.data);void 0!==options.hashfn?(assert("Function"===toTypeString(options.hashfn),"Expected options.hashfn to be a Function"),void 0!==options.xbuf&&isUint8Array("options.xbuf",options.xbuf,32),void 0!==options.ybuf&&isUint8Array("options.ybuf",options.ybuf,32),isUint8Array("output",output)):output=getAssertedOutput(output,32);switch(secp256k1.ecdh(output,pubkey,seckey,options.data,options.hashfn,options.xbuf,options.ybuf)){case 0:return output;case 1:throw Error("Public Key could not be parsed");
case 2:throw Error("Scalar was invalid (zero or overflow)");}}})}
//# sourceMappingURL=module$node_modules$secp256k1$lib$index.js.map
